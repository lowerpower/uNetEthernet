
imm.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a2  00800100  00000f66  00000ffa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f66  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000df  008001a2  008001a2  0000109c  2**0
                  ALLOC
  3 .noinit       00000000  00800281  00800281  0000109c  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  0000109c  2**0
                  CONTENTS
  5 .stab         000033b4  00000000  00000000  0000109c  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      000016a3  00000000  00000000  00004450  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c
   4:	0c 94 61 00 	jmp	0xc2
   8:	0c 94 61 00 	jmp	0xc2
   c:	0c 94 61 00 	jmp	0xc2
  10:	0c 94 61 00 	jmp	0xc2
  14:	0c 94 61 00 	jmp	0xc2
  18:	0c 94 61 00 	jmp	0xc2
  1c:	0c 94 61 00 	jmp	0xc2
  20:	0c 94 61 00 	jmp	0xc2
  24:	0c 94 61 00 	jmp	0xc2
  28:	0c 94 61 00 	jmp	0xc2
  2c:	0c 94 61 00 	jmp	0xc2
  30:	0c 94 61 00 	jmp	0xc2
  34:	0c 94 61 00 	jmp	0xc2
  38:	0c 94 61 00 	jmp	0xc2
  3c:	0c 94 61 00 	jmp	0xc2
  40:	0c 94 19 04 	jmp	0x832
  44:	0c 94 61 00 	jmp	0xc2
  48:	0c 94 38 03 	jmp	0x670
  4c:	0c 94 61 00 	jmp	0xc2
  50:	0c 94 6a 03 	jmp	0x6d4
  54:	0c 94 61 00 	jmp	0xc2
  58:	0c 94 61 00 	jmp	0xc2
  5c:	0c 94 61 00 	jmp	0xc2
  60:	0c 94 61 00 	jmp	0xc2
  64:	0c 94 61 00 	jmp	0xc2
  68:	0c 94 61 00 	jmp	0xc2
  6c:	0c 94 61 00 	jmp	0xc2
  70:	0c 94 61 00 	jmp	0xc2
  74:	0c 94 61 00 	jmp	0xc2
  78:	0c 94 61 00 	jmp	0xc2
  7c:	0c 94 61 00 	jmp	0xc2
  80:	0c 94 61 00 	jmp	0xc2
  84:	0c 94 61 00 	jmp	0xc2
  88:	0c 94 61 00 	jmp	0xc2

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e6 e6       	ldi	r30, 0x66	; 102
  a0:	ff e0       	ldi	r31, 0x0F	; 15
  a2:	02 c0       	rjmp	.+4      	; 0xa8

000000a4 <.do_copy_data_loop>:
  a4:	05 90       	lpm	r0, Z+
  a6:	0d 92       	st	X+, r0

000000a8 <.do_copy_data_start>:
  a8:	a2 3a       	cpi	r26, 0xA2	; 162
  aa:	b1 07       	cpc	r27, r17
  ac:	d9 f7       	brne	.-10     	; 0xa4

000000ae <__do_clear_bss>:
  ae:	12 e0       	ldi	r17, 0x02	; 2
  b0:	a2 ea       	ldi	r26, 0xA2	; 162
  b2:	b1 e0       	ldi	r27, 0x01	; 1
  b4:	01 c0       	rjmp	.+2      	; 0xb8

000000b6 <.do_clear_bss_loop>:
  b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
  b8:	a1 38       	cpi	r26, 0x81	; 129
  ba:	b1 07       	cpc	r27, r17
  bc:	e1 f7       	brne	.-8      	; 0xb6
  be:	0c 94 79 00 	jmp	0xf2

000000c2 <__bad_interrupt>:
  c2:	0c 94 00 00 	jmp	0x0

000000c6 <setup_hw>:
void
setup_hw(void)
{
#ifdef __AVR__
	outp(PORTBDIR,DDRB);
  c6:	88 ef       	ldi	r24, 0xF8	; 248
  c8:	87 bb       	out	0x17, r24	; 23
	outp(PORTCDIR,DDRC);
  ca:	14 ba       	out	0x14, r1	; 20
	outp(PORTDDIR,DDRD); 
  cc:	80 e9       	ldi	r24, 0x90	; 144
  ce:	81 bb       	out	0x11, r24	; 17
	outp(PORTEDIR,DDRE);
  d0:	8e e1       	ldi	r24, 0x1E	; 30
  d2:	82 b9       	out	0x02, r24	; 2
	outp(PORTGDIR,DDRG);
  d4:	88 e0       	ldi	r24, 0x08	; 8
  d6:	80 93 64 00 	sts	0x0064, r24

	// weak pullups on inputs
	outp(~PORTBDIR,PORTB);
  da:	87 e0       	ldi	r24, 0x07	; 7
  dc:	88 bb       	out	0x18, r24	; 24
	outp(~PORTCDIR,PORTC);
  de:	8f ef       	ldi	r24, 0xFF	; 255
  e0:	85 bb       	out	0x15, r24	; 21
	outp(~PORTDDIR,PORTD);
  e2:	8f e6       	ldi	r24, 0x6F	; 111
  e4:	82 bb       	out	0x12, r24	; 18
	outp(~PORTEDIR,PORTE);
  e6:	81 ee       	ldi	r24, 0xE1	; 225
  e8:	83 b9       	out	0x03, r24	; 3
	outp(~PORTGDIR,PORTG);
  ea:	87 ef       	ldi	r24, 0xF7	; 247
  ec:	80 93 65 00 	sts	0x0065, r24
	
#endif
}
  f0:	08 95       	ret

000000f2 <main>:


#ifdef WINDOWS

void
eexit(void)
{
	printf("**********");
	MODEM_close();
	exit(1);
}

void
main(argc,argv)
int 	argc;
char 	**argv;
{
int		port=1;
int		speed=19200;

	signal(SIGINT,eexit);
	if (argc==3)
	{   
		// Get com port
		port=atoi(argv[1]);
		// Get com speed
		speed=atoi(argv[2]);
    }
	else
	{
		printf("Warning: must specify both com port and speed to not use defaults.\n");
		printf("	Correct format is ppp <port> <speed>\n");
		printf("	Example: ppp 2 19200\n\n");
	}


#else

int
main()
{
  f2:	cf ef       	ldi	r28, 0xFF	; 255
  f4:	d0 e1       	ldi	r29, 0x10	; 16
  f6:	de bf       	out	0x3e, r29	; 62
  f8:	cd bf       	out	0x3d, r28	; 61
int	port=1;
int c;

//eeprom_write_byte (0,0);
#endif

	// Setup the hardware pins
	setup_hw();
  fa:	0e 94 63 00 	call	0xc6
	// Initialize the Timer
	TIMER_Init();
  fe:	0e 94 76 04 	call	0x8ec
	// Enable the interrupts
	sei();
 102:	78 94       	sei
	// Intialize the config from EEPROM or defaults
	//global_init(1);

	// If set to autobaud, autobaud the Console Serial Port and save it to mm
#ifdef __AVR__	


//	if(mm.SerialConfig & AUTOBAUD)
//	{
//		c=autobaud_setup();
//		//mm.ConsoleBaud=c;
//	}
//	else
	{
		// Load default baud/ no autobaud
		c= CONSOLE_BAUD_STATIC;//mm.ConsoleBaud;
 104:	87 e1       	ldi	r24, 0x17	; 23
 106:	90 e0       	ldi	r25, 0x00	; 0
	}

	// Initialize the Console Port 
	CONSOLE_init(c);
 108:	0e 94 e7 03 	call	0x7ce
	//CONSOLE_init(CONSOLE_BAUD_STATIC);
#endif

#ifdef __AVR__
#ifdef DEBUG_LV3	
	CONSOLE_puts("autobaud = ");
	printShort(c);
	DEBUG1(CRLF);
#endif


	//
	// Print the hello message
	//
	//CONSOLE_init(mm.ConsoleBaud);
	//if(mm.IMMConfig & BOOT_BANNER)
	{
		TIMER_Wait_Tick(20);
 10c:	84 e1       	ldi	r24, 0x14	; 20
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	0e 94 86 04 	call	0x90c
		CONSOLE_puts("uNetEthernet, Embedded Internet TCP/IP stack over Ethernet, Beta - Version "EM_VERSION CRLF);
 114:	86 e0       	ldi	r24, 0x06	; 6
 116:	91 e0       	ldi	r25, 0x01	; 1
 118:	0e 94 08 04 	call	0x810
		CONSOLE_puts("	-Beta Version build on " __DATE__ " at " __TIME__ CRLF);
 11c:	87 e5       	ldi	r24, 0x57	; 87
 11e:	91 e0       	ldi	r25, 0x01	; 1
 120:	0e 94 08 04 	call	0x810
	}
	TIMER_Wait_Tick(20);
 124:	84 e1       	ldi	r24, 0x14	; 20
 126:	90 e0       	ldi	r25, 0x00	; 0
 128:	0e 94 86 04 	call	0x90c
#endif

#ifdef __AVR__	
	//
	// This is where the AVR bootloader checker is, we should also put the CRC routing
	// in the bootloader since it will never change.
	//
	//if(mm.IMMConfig & BOOT_BANNER)
	{
		CONSOLE_puts("	-Bootloader Version ");
 12c:	89 e8       	ldi	r24, 0x89	; 137
 12e:	91 e0       	ldi	r25, 0x01	; 1
 130:	0e 94 08 04 	call	0x810
		c=boot_version();
 134:	e0 91 00 01 	lds	r30, 0x0100
 138:	f0 91 01 01 	lds	r31, 0x0101
 13c:	09 95       	icall
		printWord(c);
 13e:	0e 94 9d 02 	call	0x53a
		CONSOLE_puts(CRLF);
 142:	8f e9       	ldi	r24, 0x9F	; 159
 144:	91 e0       	ldi	r25, 0x01	; 1
 146:	0e 94 08 04 	call	0x810
	}
#endif


	// Initialize memory
	//DEBUG2("Initialize Memory Pool"CRLF);
	//MEM_init();
	
	//
	// Enable interrupts and flash Carrier Detect pin on serial iface
	//
	//MODEM_RST_ON();
	DCDI_ON();
 14a:	c7 9a       	sbi	0x18, 7	; 24
	TIMER_Wait_Tick(20);
 14c:	84 e1       	ldi	r24, 0x14	; 20
 14e:	90 e0       	ldi	r25, 0x00	; 0
 150:	0e 94 86 04 	call	0x90c
	DCDI_OFF();
 154:	c7 98       	cbi	0x18, 7	; 24
	TIMER_Wait_Tick(20);
 156:	84 e1       	ldi	r24, 0x14	; 20
 158:	90 e0       	ldi	r25, 0x00	; 0
 15a:	0e 94 86 04 	call	0x90c
	DCDI_ON();
 15e:	c7 9a       	sbi	0x18, 7	; 24
	//MODEM_RST_OFF();
	//TIMER_Wait_Tick(20);
	//
	// Initialize user serial port
	//
	DEBUG2("Nic Init"CRLF);
	nicInit();
 160:	0e 94 2b 05 	call	0xa56

	smbuff[0]=0xff;
 164:	8f ef       	ldi	r24, 0xFF	; 255
 166:	80 93 a4 01 	sts	0x01A4, r24
	smbuff[1]=0xff;
 16a:	80 93 a5 01 	sts	0x01A5, r24
	smbuff[2]=0xff;
 16e:	80 93 a6 01 	sts	0x01A6, r24
	smbuff[3]=0xff;
 172:	80 93 a7 01 	sts	0x01A7, r24
	smbuff[4]=0xff;
 176:	80 93 a8 01 	sts	0x01A8, r24
	smbuff[5]=0xff;
 17a:	80 93 a9 01 	sts	0x01A9, r24

	smbuff[6]=0xde;
 17e:	2e ed       	ldi	r18, 0xDE	; 222
 180:	20 93 aa 01 	sts	0x01AA, r18
	smbuff[7]=0xad;
 184:	9d ea       	ldi	r25, 0xAD	; 173
 186:	90 93 ab 01 	sts	0x01AB, r25
	smbuff[8]=0xbe;
 18a:	8e eb       	ldi	r24, 0xBE	; 190
 18c:	80 93 ac 01 	sts	0x01AC, r24
	smbuff[9]=0xef;
 190:	8f ee       	ldi	r24, 0xEF	; 239
 192:	80 93 ad 01 	sts	0x01AD, r24
	smbuff[10]=0xde;
 196:	20 93 ae 01 	sts	0x01AE, r18
	smbuff[11]=0xad;
 19a:	90 93 af 01 	sts	0x01AF, r25
	smbuff[12]=0x00;
 19e:	10 92 b0 01 	sts	0x01B0, r1
	smbuff[13]=0x00;
 1a2:	10 92 b1 01 	sts	0x01B1, r1


    /* Start the irCommand Processor, runs forever */
	//irCommands();
	while(1)
		nicSend(14, smbuff);
 1a6:	64 ea       	ldi	r22, 0xA4	; 164
 1a8:	71 e0       	ldi	r23, 0x01	; 1
 1aa:	8e e0       	ldi	r24, 0x0E	; 14
 1ac:	90 e0       	ldi	r25, 0x00	; 0
 1ae:	0e 94 2e 05 	call	0xa5c
 1b2:	f9 cf       	rjmp	.-14     	; 0x1a6

000001b4 <b2X>:

/* byte 2 heX ascii */
char* 
b2X( unsigned char val, char *cp ) 
{
 1b4:	98 2f       	mov	r25, r24
	*cp++ = n2X( val >>  4 );
 1b6:	fb 01       	movw	r30, r22
 1b8:	6f 5f       	subi	r22, 0xFF	; 255
 1ba:	7f 4f       	sbci	r23, 0xFF	; 255
 1bc:	82 95       	swap	r24
 1be:	8f 70       	andi	r24, 0x0F	; 15
 1c0:	28 2f       	mov	r18, r24
 1c2:	33 27       	eor	r19, r19
 1c4:	db 01       	movw	r26, r22
 1c6:	11 96       	adiw	r26, 0x01	; 1
 1c8:	8f 70       	andi	r24, 0x0F	; 15
 1ca:	49 2f       	mov	r20, r25
 1cc:	55 27       	eor	r21, r21
 1ce:	2a 30       	cpi	r18, 0x0A	; 10
 1d0:	31 05       	cpc	r19, r1
 1d2:	14 f4       	brge	.+4      	; 0x1d8
 1d4:	80 5d       	subi	r24, 0xD0	; 208
 1d6:	01 c0       	rjmp	.+2      	; 0x1da
 1d8:	89 5c       	subi	r24, 0xC9	; 201
 1da:	80 83       	st	Z, r24
	*cp++ = n2X( val );
 1dc:	fb 01       	movw	r30, r22
 1de:	4f 70       	andi	r20, 0x0F	; 15
 1e0:	50 70       	andi	r21, 0x00	; 0
 1e2:	89 2f       	mov	r24, r25
 1e4:	8f 70       	andi	r24, 0x0F	; 15
 1e6:	4a 30       	cpi	r20, 0x0A	; 10
 1e8:	51 05       	cpc	r21, r1
 1ea:	14 f4       	brge	.+4      	; 0x1f0
 1ec:	80 5d       	subi	r24, 0xD0	; 208
 1ee:	01 c0       	rjmp	.+2      	; 0x1f2
 1f0:	89 5c       	subi	r24, 0xC9	; 201
 1f2:	80 83       	st	Z, r24
	*cp = '\0';
 1f4:	1c 92       	st	X, r1
	return cp;
}
 1f6:	cd 01       	movw	r24, r26
 1f8:	08 95       	ret

000001fa <s2X>:

/* short 2 heX ascii */
char* 
s2X( unsigned short val, char *cp ) 
{
 1fa:	cf 93       	push	r28
 1fc:	df 93       	push	r29
 1fe:	ac 01       	movw	r20, r24
	*cp++ = n2X( val >> 12 );
 200:	eb 01       	movw	r28, r22
 202:	6f 5f       	subi	r22, 0xFF	; 255
 204:	7f 4f       	sbci	r23, 0xFF	; 255
 206:	89 2f       	mov	r24, r25
 208:	99 27       	eor	r25, r25
 20a:	82 95       	swap	r24
 20c:	8f 70       	andi	r24, 0x0F	; 15
 20e:	fb 01       	movw	r30, r22
 210:	31 96       	adiw	r30, 0x01	; 1
 212:	a8 2f       	mov	r26, r24
 214:	af 70       	andi	r26, 0x0F	; 15
 216:	25 2f       	mov	r18, r21
 218:	33 27       	eor	r19, r19
 21a:	0a 97       	sbiw	r24, 0x0a	; 10
 21c:	18 f4       	brcc	.+6      	; 0x224
 21e:	8a 2f       	mov	r24, r26
 220:	80 5d       	subi	r24, 0xD0	; 208
 222:	02 c0       	rjmp	.+4      	; 0x228
 224:	8a 2f       	mov	r24, r26
 226:	89 5c       	subi	r24, 0xC9	; 201
 228:	88 83       	st	Y, r24
	*cp++ = n2X( val >>  8 );
 22a:	eb 01       	movw	r28, r22
 22c:	bf 01       	movw	r22, r30
 22e:	31 96       	adiw	r30, 0x01	; 1
 230:	a2 2f       	mov	r26, r18
 232:	af 70       	andi	r26, 0x0F	; 15
 234:	ca 01       	movw	r24, r20
 236:	b4 e0       	ldi	r27, 0x04	; 4
 238:	96 95       	lsr	r25
 23a:	87 95       	ror	r24
 23c:	ba 95       	dec	r27
 23e:	e1 f7       	brne	.-8      	; 0x238
 240:	2f 70       	andi	r18, 0x0F	; 15
 242:	30 70       	andi	r19, 0x00	; 0
 244:	2a 30       	cpi	r18, 0x0A	; 10
 246:	31 05       	cpc	r19, r1
 248:	18 f4       	brcc	.+6      	; 0x250
 24a:	2a 2f       	mov	r18, r26
 24c:	20 5d       	subi	r18, 0xD0	; 208
 24e:	02 c0       	rjmp	.+4      	; 0x254
 250:	2a 2f       	mov	r18, r26
 252:	29 5c       	subi	r18, 0xC9	; 201
 254:	28 83       	st	Y, r18
	*cp++ = n2X( val >>  4 );
 256:	db 01       	movw	r26, r22
 258:	bf 01       	movw	r22, r30
 25a:	31 96       	adiw	r30, 0x01	; 1
 25c:	28 2f       	mov	r18, r24
 25e:	2f 70       	andi	r18, 0x0F	; 15
 260:	ea 01       	movw	r28, r20
 262:	cf 70       	andi	r28, 0x0F	; 15
 264:	d0 70       	andi	r29, 0x00	; 0
 266:	8f 70       	andi	r24, 0x0F	; 15
 268:	90 70       	andi	r25, 0x00	; 0
 26a:	0a 97       	sbiw	r24, 0x0a	; 10
 26c:	18 f4       	brcc	.+6      	; 0x274
 26e:	82 2f       	mov	r24, r18
 270:	80 5d       	subi	r24, 0xD0	; 208
 272:	02 c0       	rjmp	.+4      	; 0x278
 274:	82 2f       	mov	r24, r18
 276:	89 5c       	subi	r24, 0xC9	; 201
 278:	8c 93       	st	X, r24
	*cp++ = n2X( val );
 27a:	db 01       	movw	r26, r22
 27c:	84 2f       	mov	r24, r20
 27e:	8f 70       	andi	r24, 0x0F	; 15
 280:	2a 97       	sbiw	r28, 0x0a	; 10
 282:	10 f4       	brcc	.+4      	; 0x288
 284:	80 5d       	subi	r24, 0xD0	; 208
 286:	01 c0       	rjmp	.+2      	; 0x28a
 288:	89 5c       	subi	r24, 0xC9	; 201
 28a:	8c 93       	st	X, r24
	*cp = '\0';
 28c:	10 82       	st	Z, r1
	return cp;
}
 28e:	cf 01       	movw	r24, r30
 290:	df 91       	pop	r29
 292:	cf 91       	pop	r28
 294:	08 95       	ret

00000296 <s2ip>:


/* ascii to ip addr */
char *
s2ip( char *cp, IPAddr *ip ) 
{
 296:	ef 92       	push	r14
 298:	ff 92       	push	r15
 29a:	0f 93       	push	r16
 29c:	1f 93       	push	r17
 29e:	cf 93       	push	r28
 2a0:	df 93       	push	r29
 2a2:	dc 01       	movw	r26, r24
 2a4:	8b 01       	movw	r16, r22
    IPAddr lip;
    char *lcp = cp;  
 2a6:	fc 01       	movw	r30, r24
    char *sp=cp;
 2a8:	7c 01       	movw	r14, r24

	lip.ip32 = 0;
 2aa:	40 e0       	ldi	r20, 0x00	; 0
 2ac:	50 e0       	ldi	r21, 0x00	; 0
 2ae:	60 e0       	ldi	r22, 0x00	; 0
 2b0:	70 e0       	ldi	r23, 0x00	; 0

	/* eg: MS.ms.ls.LS */

    /* MS --> */
	while( ( '0' <= *lcp ) && ( '9' >= *lcp ) )
 2b2:	2c 91       	ld	r18, X
 2b4:	82 2f       	mov	r24, r18
 2b6:	80 53       	subi	r24, 0x30	; 48
 2b8:	8a 30       	cpi	r24, 0x0A	; 10
 2ba:	68 f4       	brcc	.+26     	; 0x2d6
    {
		lip.ipb1 = ( lip.ipb1 * 10 ) + (*lcp++ - '0');
 2bc:	8a e0       	ldi	r24, 0x0A	; 10
 2be:	48 9f       	mul	r20, r24
 2c0:	c0 01       	movw	r24, r0
 2c2:	11 24       	eor	r1, r1
 2c4:	28 0f       	add	r18, r24
 2c6:	42 2f       	mov	r20, r18
 2c8:	40 53       	subi	r20, 0x30	; 48
 2ca:	31 96       	adiw	r30, 0x01	; 1
 2cc:	20 81       	ld	r18, Z
 2ce:	82 2f       	mov	r24, r18
 2d0:	80 53       	subi	r24, 0x30	; 48
 2d2:	8a 30       	cpi	r24, 0x0A	; 10
 2d4:	98 f3       	brcs	.-26     	; 0x2bc
    }

	if (cp == lcp) return sp; /* watch for no number */
 2d6:	ae 17       	cp	r26, r30
 2d8:	bf 07       	cpc	r27, r31
 2da:	09 f4       	brne	.+2      	; 0x2de
 2dc:	54 c0       	rjmp	.+168    	; 0x386
	//if (lip.ipb1 >= 0x100) return lcp;/* watch for .256. */
    /* <-- MS */

    cp = lcp;
 2de:	df 01       	movw	r26, r30
	if ('.' != *lcp++) return sp; /* watch for no '.' */
 2e0:	81 91       	ld	r24, Z+
 2e2:	8e 32       	cpi	r24, 0x2E	; 46
 2e4:	09 f0       	breq	.+2      	; 0x2e8
 2e6:	47 c0       	rjmp	.+142    	; 0x376

    /* ms --> */
	while( ( '0' <= *lcp ) && ( '9' >= *lcp ) )
 2e8:	11 96       	adiw	r26, 0x01	; 1
 2ea:	8c 91       	ld	r24, X
 2ec:	11 97       	sbiw	r26, 0x01	; 1
 2ee:	80 53       	subi	r24, 0x30	; 48
 2f0:	8a 30       	cpi	r24, 0x0A	; 10
 2f2:	60 f4       	brcc	.+24     	; 0x30c
    {
		lip.ipb2 = ( lip.ipb2 * 10 ) + (*lcp++ - '0');
 2f4:	8a e0       	ldi	r24, 0x0A	; 10
 2f6:	58 9f       	mul	r21, r24
 2f8:	90 01       	movw	r18, r0
 2fa:	11 24       	eor	r1, r1
 2fc:	81 91       	ld	r24, Z+
 2fe:	82 0f       	add	r24, r18
 300:	58 2f       	mov	r21, r24
 302:	50 53       	subi	r21, 0x30	; 48
 304:	80 81       	ld	r24, Z
 306:	80 53       	subi	r24, 0x30	; 48
 308:	8a 30       	cpi	r24, 0x0A	; 10
 30a:	a0 f3       	brcs	.-24     	; 0x2f4
    }

	if (cp == lcp) return sp; /* watch for no number */
 30c:	ae 17       	cp	r26, r30
 30e:	bf 07       	cpc	r27, r31
 310:	91 f1       	breq	.+100    	; 0x376
	//if (lip.ipb2 >= 0x100) return sp;/* watch for .256. */
    /* <-- ms */

    cp = lcp;
 312:	df 01       	movw	r26, r30
	if ('.' != *lcp++) return sp; /* watch for no '.' */
 314:	81 91       	ld	r24, Z+
 316:	8e 32       	cpi	r24, 0x2E	; 46
 318:	71 f5       	brne	.+92     	; 0x376

    /* ls --> */
	while( ( '0' <= *lcp ) && ( '9' >= *lcp ) )
 31a:	11 96       	adiw	r26, 0x01	; 1
 31c:	8c 91       	ld	r24, X
 31e:	11 97       	sbiw	r26, 0x01	; 1
 320:	80 53       	subi	r24, 0x30	; 48
 322:	8a 30       	cpi	r24, 0x0A	; 10
 324:	60 f4       	brcc	.+24     	; 0x33e
    {
		lip.ipb3 = ( lip.ipb3 * 10 ) + (*lcp++ - '0');
 326:	8a e0       	ldi	r24, 0x0A	; 10
 328:	68 9f       	mul	r22, r24
 32a:	90 01       	movw	r18, r0
 32c:	11 24       	eor	r1, r1
 32e:	81 91       	ld	r24, Z+
 330:	82 0f       	add	r24, r18
 332:	68 2f       	mov	r22, r24
 334:	60 53       	subi	r22, 0x30	; 48
 336:	80 81       	ld	r24, Z
 338:	80 53       	subi	r24, 0x30	; 48
 33a:	8a 30       	cpi	r24, 0x0A	; 10
 33c:	a0 f3       	brcs	.-24     	; 0x326
    }

	if (cp == lcp) return sp; /* watch for no number */
 33e:	ae 17       	cp	r26, r30
 340:	bf 07       	cpc	r27, r31
 342:	c9 f0       	breq	.+50     	; 0x376
	//if (lip.ipb3 >= 0x100) return sp;/* watch for .256. */
    /* <-- ls */

    cp = lcp;
 344:	df 01       	movw	r26, r30
	if ('.' != *lcp++) return sp; /* watch for no '.' */
 346:	81 91       	ld	r24, Z+
 348:	8e 32       	cpi	r24, 0x2E	; 46
 34a:	a9 f4       	brne	.+42     	; 0x376

    /* LS --> */
	while( ( '0' <= *lcp ) && ( '9' >= *lcp ) )
 34c:	11 96       	adiw	r26, 0x01	; 1
 34e:	8c 91       	ld	r24, X
 350:	11 97       	sbiw	r26, 0x01	; 1
 352:	80 53       	subi	r24, 0x30	; 48
 354:	8a 30       	cpi	r24, 0x0A	; 10
 356:	60 f4       	brcc	.+24     	; 0x370
    {
		lip.ipb4 = ( lip.ipb4 * 10 ) + (*lcp++ - '0');
 358:	8a e0       	ldi	r24, 0x0A	; 10
 35a:	78 9f       	mul	r23, r24
 35c:	90 01       	movw	r18, r0
 35e:	11 24       	eor	r1, r1
 360:	81 91       	ld	r24, Z+
 362:	82 0f       	add	r24, r18
 364:	78 2f       	mov	r23, r24
 366:	70 53       	subi	r23, 0x30	; 48
 368:	80 81       	ld	r24, Z
 36a:	80 53       	subi	r24, 0x30	; 48
 36c:	8a 30       	cpi	r24, 0x0A	; 10
 36e:	a0 f3       	brcs	.-24     	; 0x358
    }

	if (cp == lcp) return sp; /* watch for no number */
 370:	ae 17       	cp	r26, r30
 372:	bf 07       	cpc	r27, r31
 374:	11 f4       	brne	.+4      	; 0x37a
 376:	c7 01       	movw	r24, r14
 378:	07 c0       	rjmp	.+14     	; 0x388
	//if (lip.ipb4 >= 0x100) return sp;/* watch for .256. */
    /* <-- LS */

    cp = lcp;
    *ip = lip;
 37a:	d8 01       	movw	r26, r16
 37c:	4d 93       	st	X+, r20
 37e:	5d 93       	st	X+, r21
 380:	6d 93       	st	X+, r22
 382:	7c 93       	st	X, r23
 384:	13 97       	sbiw	r26, 0x03	; 3

	return cp;		/* OK */
 386:	cf 01       	movw	r24, r30
}
 388:	df 91       	pop	r29
 38a:	cf 91       	pop	r28
 38c:	1f 91       	pop	r17
 38e:	0f 91       	pop	r16
 390:	ff 90       	pop	r15
 392:	ef 90       	pop	r14
 394:	08 95       	ret

00000396 <d2s>:




/* decimal ascii string to short */
unsigned short 
d2s( char *cp ) 
{
 396:	fc 01       	movw	r30, r24
	unsigned short val = 0;
 398:	20 e0       	ldi	r18, 0x00	; 0
 39a:	30 e0       	ldi	r19, 0x00	; 0
	while((*cp>='0') && (*cp<='9')) 
 39c:	40 81       	ld	r20, Z
 39e:	84 2f       	mov	r24, r20
 3a0:	80 53       	subi	r24, 0x30	; 48
 3a2:	8a 30       	cpi	r24, 0x0A	; 10
 3a4:	a0 f4       	brcc	.+40     	; 0x3ce
    {
		val *= 10;
 3a6:	c9 01       	movw	r24, r18
 3a8:	53 e0       	ldi	r21, 0x03	; 3
 3aa:	88 0f       	add	r24, r24
 3ac:	99 1f       	adc	r25, r25
 3ae:	5a 95       	dec	r21
 3b0:	e1 f7       	brne	.-8      	; 0x3aa
 3b2:	82 0f       	add	r24, r18
 3b4:	93 1f       	adc	r25, r19
 3b6:	28 0f       	add	r18, r24
 3b8:	39 1f       	adc	r19, r25
	    val += (unsigned short)(*cp-'0');			//d2n(*cp);
 3ba:	24 0f       	add	r18, r20
 3bc:	31 1d       	adc	r19, r1
 3be:	20 53       	subi	r18, 0x30	; 48
 3c0:	30 40       	sbci	r19, 0x00	; 0
        ++cp;
 3c2:	31 96       	adiw	r30, 0x01	; 1
 3c4:	40 81       	ld	r20, Z
 3c6:	84 2f       	mov	r24, r20
 3c8:	80 53       	subi	r24, 0x30	; 48
 3ca:	8a 30       	cpi	r24, 0x0A	; 10
 3cc:	60 f3       	brcs	.-40     	; 0x3a6
	}
	return val;
}
 3ce:	c9 01       	movw	r24, r18
 3d0:	08 95       	ret

000003d2 <s2p>:
 
/* ascii to ipport */
char
*s2p( char *str, unsigned short *port ) 
{
 3d2:	fc 01       	movw	r30, r24
 3d4:	db 01       	movw	r26, r22
    *port = 0;
 3d6:	1d 92       	st	X+, r1
 3d8:	1c 92       	st	X, r1
 3da:	11 97       	sbiw	r26, 0x01	; 1
	while( ( '0' <= *str ) && ( '9' >= *str ) )
 3dc:	80 81       	ld	r24, Z
 3de:	80 53       	subi	r24, 0x30	; 48
 3e0:	8a 30       	cpi	r24, 0x0A	; 10
 3e2:	d8 f4       	brcc	.+54     	; 0x41a
    {
		*port = ((Port)*port) * ((U16)10);
 3e4:	2d 91       	ld	r18, X+
 3e6:	3c 91       	ld	r19, X
 3e8:	11 97       	sbiw	r26, 0x01	; 1
 3ea:	c9 01       	movw	r24, r18
 3ec:	63 e0       	ldi	r22, 0x03	; 3
 3ee:	88 0f       	add	r24, r24
 3f0:	99 1f       	adc	r25, r25
 3f2:	6a 95       	dec	r22
 3f4:	e1 f7       	brne	.-8      	; 0x3ee
 3f6:	82 0f       	add	r24, r18
 3f8:	93 1f       	adc	r25, r19
 3fa:	82 0f       	add	r24, r18
 3fc:	93 1f       	adc	r25, r19
 3fe:	8d 93       	st	X+, r24
 400:	9c 93       	st	X, r25
 402:	11 97       	sbiw	r26, 0x01	; 1
	    *port += ((U16)*str-'0');	//d2n(*str));
 404:	21 91       	ld	r18, Z+
 406:	82 0f       	add	r24, r18
 408:	91 1d       	adc	r25, r1
 40a:	c0 97       	sbiw	r24, 0x30	; 48
 40c:	8d 93       	st	X+, r24
 40e:	9c 93       	st	X, r25
 410:	11 97       	sbiw	r26, 0x01	; 1
        ++str;
 412:	80 81       	ld	r24, Z
 414:	80 53       	subi	r24, 0x30	; 48
 416:	8a 30       	cpi	r24, 0x0A	; 10
 418:	28 f3       	brcs	.-54     	; 0x3e4
	}
    return str;
}
 41a:	cf 01       	movw	r24, r30
 41c:	08 95       	ret

0000041e <_2d>:


/* to decimal ascii */
char 
*_2d( unsigned short val, char *cp, unsigned short dec_digits, unsigned char pad ) 
{	
 41e:	0f 93       	push	r16
 420:	1f 93       	push	r17
 422:	cf 93       	push	r28
 424:	df 93       	push	r29
 426:	ec 01       	movw	r28, r24
 428:	fb 01       	movw	r30, r22
 42a:	12 2f       	mov	r17, r18
	unsigned theDigit;
	unsigned short dv;
    unsigned char fill = 0;   
 42c:	00 e0       	ldi	r16, 0x00	; 0
    
	if( (0 == val) && (0 == pad) ) 
 42e:	89 2b       	or	r24, r25
 430:	29 f4       	brne	.+10     	; 0x43c
 432:	22 23       	and	r18, r18
 434:	19 f4       	brne	.+6      	; 0x43c
    {
		*cp++ = '0';
 436:	80 e3       	ldi	r24, 0x30	; 48
 438:	81 93       	st	Z+, r24
 43a:	30 c0       	rjmp	.+96     	; 0x49c
	}
	else 
    {
		for( dv = dec_digits; dv; dv /= 10 ) 
 43c:	9a 01       	movw	r18, r20
 43e:	45 2b       	or	r20, r21
 440:	69 f1       	breq	.+90     	; 0x49c
        {
			theDigit = val / dv;
 442:	ce 01       	movw	r24, r28
 444:	b9 01       	movw	r22, r18
 446:	0e 94 9f 07 	call	0xf3e
			if( theDigit || fill ) 
 44a:	61 15       	cp	r22, r1
 44c:	71 05       	cpc	r23, r1
 44e:	11 f4       	brne	.+4      	; 0x454
 450:	00 23       	and	r16, r16
 452:	c1 f0       	breq	.+48     	; 0x484
            {
				*cp++ = n2d( theDigit );	/* ascii */
 454:	df 01       	movw	r26, r30
 456:	31 96       	adiw	r30, 0x01	; 1
 458:	86 2f       	mov	r24, r22
 45a:	8f 70       	andi	r24, 0x0F	; 15
 45c:	62 9f       	mul	r22, r18
 45e:	a0 01       	movw	r20, r0
 460:	63 9f       	mul	r22, r19
 462:	50 0d       	add	r21, r0
 464:	72 9f       	mul	r23, r18
 466:	50 0d       	add	r21, r0
 468:	11 24       	eor	r1, r1
 46a:	6f 70       	andi	r22, 0x0F	; 15
 46c:	70 70       	andi	r23, 0x00	; 0
 46e:	6a 30       	cpi	r22, 0x0A	; 10
 470:	71 05       	cpc	r23, r1
 472:	10 f4       	brcc	.+4      	; 0x478
 474:	80 5d       	subi	r24, 0xD0	; 208
 476:	01 c0       	rjmp	.+2      	; 0x47a
 478:	89 5c       	subi	r24, 0xC9	; 201
 47a:	8c 93       	st	X, r24
				val -= theDigit * dv;
 47c:	c4 1b       	sub	r28, r20
 47e:	d5 0b       	sbc	r29, r21
                fill = 1;
 480:	01 e0       	ldi	r16, 0x01	; 1
 482:	04 c0       	rjmp	.+8      	; 0x48c
			}
            else 
            {
                if( pad ) *cp++ = '0';
 484:	11 23       	and	r17, r17
 486:	11 f0       	breq	.+4      	; 0x48c
 488:	80 e3       	ldi	r24, 0x30	; 48
 48a:	81 93       	st	Z+, r24
 48c:	c9 01       	movw	r24, r18
 48e:	6a e0       	ldi	r22, 0x0A	; 10
 490:	70 e0       	ldi	r23, 0x00	; 0
 492:	0e 94 9f 07 	call	0xf3e
 496:	9b 01       	movw	r18, r22
 498:	67 2b       	or	r22, r23
 49a:	99 f6       	brne	.-90     	; 0x442
            }
		}
	}
	*cp = '\0';
 49c:	10 82       	st	Z, r1
	return cp;
}       
 49e:	cf 01       	movw	r24, r30
 4a0:	df 91       	pop	r29
 4a2:	cf 91       	pop	r28
 4a4:	1f 91       	pop	r17
 4a6:	0f 91       	pop	r16
 4a8:	08 95       	ret

000004aa <X2s>:



/* hex ascii string to short */
unsigned short 
X2s( char *cp ) 
{
 4aa:	fc 01       	movw	r30, r24
	unsigned short val = 0;
 4ac:	20 e0       	ldi	r18, 0x00	; 0
 4ae:	30 e0       	ldi	r19, 0x00	; 0
	while(( *cp > 32 ) && (*cp != '='))
 4b0:	80 81       	ld	r24, Z
 4b2:	81 32       	cpi	r24, 0x21	; 33
 4b4:	58 f1       	brcs	.+86     	; 0x50c
 4b6:	8d 33       	cpi	r24, 0x3D	; 61
 4b8:	49 f1       	breq	.+82     	; 0x50c
    {
		val *= 0x10;
 4ba:	74 e0       	ldi	r23, 0x04	; 4
 4bc:	22 0f       	add	r18, r18
 4be:	33 1f       	adc	r19, r19
 4c0:	7a 95       	dec	r23
 4c2:	e1 f7       	brne	.-8      	; 0x4bc
	    val += X2n(*cp);
 4c4:	90 81       	ld	r25, Z
 4c6:	89 2f       	mov	r24, r25
 4c8:	80 53       	subi	r24, 0x30	; 48
 4ca:	8a 30       	cpi	r24, 0x0A	; 10
 4cc:	28 f4       	brcc	.+10     	; 0x4d8
 4ce:	29 0f       	add	r18, r25
 4d0:	31 1d       	adc	r19, r1
 4d2:	20 53       	subi	r18, 0x30	; 48
 4d4:	30 40       	sbci	r19, 0x00	; 0
 4d6:	14 c0       	rjmp	.+40     	; 0x500
 4d8:	89 2f       	mov	r24, r25
 4da:	81 56       	subi	r24, 0x61	; 97
 4dc:	86 30       	cpi	r24, 0x06	; 6
 4de:	28 f4       	brcc	.+10     	; 0x4ea
 4e0:	29 0f       	add	r18, r25
 4e2:	31 1d       	adc	r19, r1
 4e4:	27 55       	subi	r18, 0x57	; 87
 4e6:	30 40       	sbci	r19, 0x00	; 0
 4e8:	0b c0       	rjmp	.+22     	; 0x500
 4ea:	89 2f       	mov	r24, r25
 4ec:	81 54       	subi	r24, 0x41	; 65
 4ee:	86 30       	cpi	r24, 0x06	; 6
 4f0:	28 f4       	brcc	.+10     	; 0x4fc
 4f2:	29 0f       	add	r18, r25
 4f4:	31 1d       	adc	r19, r1
 4f6:	27 53       	subi	r18, 0x37	; 55
 4f8:	30 40       	sbci	r19, 0x00	; 0
 4fa:	02 c0       	rjmp	.+4      	; 0x500
 4fc:	21 50       	subi	r18, 0x01	; 1
 4fe:	3f 4f       	sbci	r19, 0xFF	; 255
        ++cp;
 500:	31 96       	adiw	r30, 0x01	; 1
 502:	80 81       	ld	r24, Z
 504:	81 32       	cpi	r24, 0x21	; 33
 506:	10 f0       	brcs	.+4      	; 0x50c
 508:	8d 33       	cpi	r24, 0x3D	; 61
 50a:	b9 f6       	brne	.-82     	; 0x4ba
	}
	return val;
}
 50c:	c9 01       	movw	r24, r18
 50e:	08 95       	ret

00000510 <printShort>:

void
printShort(U16 t)
{   
	//
	// Printout either ASCII dec short
	//
	s2d( t, smbuff );
 510:	20 e0       	ldi	r18, 0x00	; 0
 512:	40 e1       	ldi	r20, 0x10	; 16
 514:	57 e2       	ldi	r21, 0x27	; 39
 516:	64 ea       	ldi	r22, 0xA4	; 164
 518:	71 e0       	ldi	r23, 0x01	; 1
 51a:	0e 94 0f 02 	call	0x41e
	CONSOLE_puts(smbuff);
 51e:	84 ea       	ldi	r24, 0xA4	; 164
 520:	91 e0       	ldi	r25, 0x01	; 1
 522:	0e 94 08 04 	call	0x810
}
 526:	08 95       	ret

00000528 <printByte>:

void
printByte(U8 t)
{   
	//
	// Printout either ASCII dec short
	//
	b2X(t, smbuff);
 528:	64 ea       	ldi	r22, 0xA4	; 164
 52a:	71 e0       	ldi	r23, 0x01	; 1
 52c:	0e 94 da 00 	call	0x1b4
	CONSOLE_puts(smbuff);
 530:	84 ea       	ldi	r24, 0xA4	; 164
 532:	91 e0       	ldi	r25, 0x01	; 1
 534:	0e 94 08 04 	call	0x810
}
 538:	08 95       	ret

0000053a <printWord>:

void
printWord(U16 t)
{   
	//
	// Printout either ASCII dec short
	//
	s2X(t, smbuff);
 53a:	64 ea       	ldi	r22, 0xA4	; 164
 53c:	71 e0       	ldi	r23, 0x01	; 1
 53e:	0e 94 fd 00 	call	0x1fa
	CONSOLE_puts(smbuff);
 542:	84 ea       	ldi	r24, 0xA4	; 164
 544:	91 e0       	ldi	r25, 0x01	; 1
 546:	0e 94 08 04 	call	0x810
}
 54a:	08 95       	ret

0000054c <printDWord>:

void
printDWord(U32 t)
{   
 54c:	cf 93       	push	r28
 54e:	df 93       	push	r29
 550:	cd b7       	in	r28, 0x3d	; 61
 552:	de b7       	in	r29, 0x3e	; 62
 554:	24 97       	sbiw	r28, 0x04	; 4
 556:	0f b6       	in	r0, 0x3f	; 63
 558:	f8 94       	cli
 55a:	de bf       	out	0x3e, r29	; 62
 55c:	0f be       	out	0x3f, r0	; 63
 55e:	cd bf       	out	0x3d, r28	; 61
 560:	69 83       	std	Y+1, r22	; 0x01
 562:	7a 83       	std	Y+2, r23	; 0x02
 564:	8b 83       	std	Y+3, r24	; 0x03
 566:	9c 83       	std	Y+4, r25	; 0x04
U8	*tptr;
	//
	// Printout either ASCII dec short
	//
	tptr=(U8 *)&t;
	printByte(tptr[3]);
 568:	8c 81       	ldd	r24, Y+4	; 0x04
 56a:	0e 94 94 02 	call	0x528
	printByte(tptr[2]);
 56e:	8b 81       	ldd	r24, Y+3	; 0x03
 570:	0e 94 94 02 	call	0x528
	printByte(tptr[1]);
 574:	fe 01       	movw	r30, r28
 576:	31 96       	adiw	r30, 0x01	; 1
 578:	81 81       	ldd	r24, Z+1	; 0x01
 57a:	0e 94 94 02 	call	0x528
	printByte(tptr[0]);
 57e:	89 81       	ldd	r24, Y+1	; 0x01
 580:	0e 94 94 02 	call	0x528
}
 584:	24 96       	adiw	r28, 0x04	; 4
 586:	0f b6       	in	r0, 0x3f	; 63
 588:	f8 94       	cli
 58a:	de bf       	out	0x3e, r29	; 62
 58c:	0f be       	out	0x3f, r0	; 63
 58e:	cd bf       	out	0x3d, r28	; 61
 590:	df 91       	pop	r29
 592:	cf 91       	pop	r28
 594:	08 95       	ret

00000596 <printIP>:


void
printIP(iIPAddr *ip)
{   
 596:	0f 93       	push	r16
 598:	1f 93       	push	r17
 59a:	8c 01       	movw	r16, r24
	//
	// printout either ASCII ip dot quad string
	//
		//
		// Write the IP address as ASC string
		//		
		b2d(ip->ipb1, smbuff);
 59c:	fc 01       	movw	r30, r24
 59e:	80 81       	ld	r24, Z
 5a0:	99 27       	eor	r25, r25
 5a2:	20 e0       	ldi	r18, 0x00	; 0
 5a4:	44 e6       	ldi	r20, 0x64	; 100
 5a6:	50 e0       	ldi	r21, 0x00	; 0
 5a8:	64 ea       	ldi	r22, 0xA4	; 164
 5aa:	71 e0       	ldi	r23, 0x01	; 1
 5ac:	0e 94 0f 02 	call	0x41e
		CONSOLE_puts(smbuff);
 5b0:	84 ea       	ldi	r24, 0xA4	; 164
 5b2:	91 e0       	ldi	r25, 0x01	; 1
 5b4:	0e 94 08 04 	call	0x810
		CONSOLE_putch('.');
 5b8:	8e e2       	ldi	r24, 0x2E	; 46
 5ba:	0e 94 ea 03 	call	0x7d4
	
		b2d(ip->ipb2, smbuff);
 5be:	f8 01       	movw	r30, r16
 5c0:	81 81       	ldd	r24, Z+1	; 0x01
 5c2:	99 27       	eor	r25, r25
 5c4:	20 e0       	ldi	r18, 0x00	; 0
 5c6:	44 e6       	ldi	r20, 0x64	; 100
 5c8:	50 e0       	ldi	r21, 0x00	; 0
 5ca:	64 ea       	ldi	r22, 0xA4	; 164
 5cc:	71 e0       	ldi	r23, 0x01	; 1
 5ce:	0e 94 0f 02 	call	0x41e
		CONSOLE_puts(smbuff);
 5d2:	84 ea       	ldi	r24, 0xA4	; 164
 5d4:	91 e0       	ldi	r25, 0x01	; 1
 5d6:	0e 94 08 04 	call	0x810
		CONSOLE_putch('.');
 5da:	8e e2       	ldi	r24, 0x2E	; 46
 5dc:	0e 94 ea 03 	call	0x7d4

		b2d(ip->ipb3, smbuff);
 5e0:	f8 01       	movw	r30, r16
 5e2:	82 81       	ldd	r24, Z+2	; 0x02
 5e4:	99 27       	eor	r25, r25
 5e6:	20 e0       	ldi	r18, 0x00	; 0
 5e8:	44 e6       	ldi	r20, 0x64	; 100
 5ea:	50 e0       	ldi	r21, 0x00	; 0
 5ec:	64 ea       	ldi	r22, 0xA4	; 164
 5ee:	71 e0       	ldi	r23, 0x01	; 1
 5f0:	0e 94 0f 02 	call	0x41e
		CONSOLE_puts(smbuff);
 5f4:	84 ea       	ldi	r24, 0xA4	; 164
 5f6:	91 e0       	ldi	r25, 0x01	; 1
 5f8:	0e 94 08 04 	call	0x810
		CONSOLE_putch('.');
 5fc:	8e e2       	ldi	r24, 0x2E	; 46
 5fe:	0e 94 ea 03 	call	0x7d4
	
		b2d(ip->ipb4, smbuff);
 602:	f8 01       	movw	r30, r16
 604:	83 81       	ldd	r24, Z+3	; 0x03
 606:	99 27       	eor	r25, r25
 608:	20 e0       	ldi	r18, 0x00	; 0
 60a:	44 e6       	ldi	r20, 0x64	; 100
 60c:	50 e0       	ldi	r21, 0x00	; 0
 60e:	64 ea       	ldi	r22, 0xA4	; 164
 610:	71 e0       	ldi	r23, 0x01	; 1
 612:	0e 94 0f 02 	call	0x41e
		CONSOLE_puts(smbuff);
 616:	84 ea       	ldi	r24, 0xA4	; 164
 618:	91 e0       	ldi	r25, 0x01	; 1
 61a:	0e 94 08 04 	call	0x810
}
 61e:	1f 91       	pop	r17
 620:	0f 91       	pop	r16
 622:	08 95       	ret

00000624 <Get_Byte>:



//
// 
//
U8
*Get_Byte(U8 *ptr, U8 *val)
{
 624:	0f 93       	push	r16
 626:	1f 93       	push	r17
 628:	cf 93       	push	r28
 62a:	df 93       	push	r29
 62c:	ec 01       	movw	r28, r24
 62e:	8b 01       	movw	r16, r22
	//
	// Dump Spaces
	//
	while(*ptr==' ')
 630:	88 81       	ld	r24, Y
 632:	80 32       	cpi	r24, 0x20	; 32
 634:	21 f4       	brne	.+8      	; 0x63e
			ptr++ ;
 636:	21 96       	adiw	r28, 0x01	; 1
 638:	88 81       	ld	r24, Y
 63a:	80 32       	cpi	r24, 0x20	; 32
 63c:	e1 f3       	breq	.-8      	; 0x636

	smbuff[0]=(*ptr++ | 0x20);
 63e:	89 91       	ld	r24, Y+
 640:	80 62       	ori	r24, 0x20	; 32
 642:	80 93 a4 01 	sts	0x01A4, r24
	smbuff[1]=(*ptr++ | 0x20);
 646:	89 91       	ld	r24, Y+
 648:	80 62       	ori	r24, 0x20	; 32
 64a:	80 93 a5 01 	sts	0x01A5, r24
	smbuff[2]=0;
 64e:	10 92 a6 01 	sts	0x01A6, r1
	
	if('='==smbuff[1])
 652:	8d 33       	cpi	r24, 0x3D	; 61
 654:	09 f4       	brne	.+2      	; 0x658
	{
		ptr--;
 656:	21 97       	sbiw	r28, 0x01	; 1
	}

	// Convert
	*val=(unsigned char)X2s(&smbuff[0]); 
 658:	84 ea       	ldi	r24, 0xA4	; 164
 65a:	91 e0       	ldi	r25, 0x01	; 1
 65c:	0e 94 55 02 	call	0x4aa
 660:	f8 01       	movw	r30, r16
 662:	80 83       	st	Z, r24
	return(ptr);
}
 664:	ce 01       	movw	r24, r28
 666:	df 91       	pop	r29
 668:	cf 91       	pop	r28
 66a:	1f 91       	pop	r17
 66c:	0f 91       	pop	r16
 66e:	08 95       	ret

00000670 <__vector_18>:


/* UART0 Receive Complete Interrupt Function */
SIGNAL(SIG_UART0_RECV)      
{    
 670:	1f 92       	push	r1
 672:	0f 92       	push	r0
 674:	0f b6       	in	r0, 0x3f	; 63
 676:	0f 92       	push	r0
 678:	11 24       	eor	r1, r1
 67a:	8f 93       	push	r24
 67c:	9f 93       	push	r25
 67e:	ef 93       	push	r30
 680:	ff 93       	push	r31
U8	c;             

	RXI0_ON();
 682:	c5 9a       	sbi	0x18, 5	; 24
    /* Get incomming char */
    c = inp(UDR0);
 684:	9c b1       	in	r25, 0x0c	; 12
    
	/* check for room on the fifo, if so store the char, else we toss it. */
	if(UART0_RxSize<UART0_RX_BUFFER_SIZE)
 686:	80 91 f5 01 	lds	r24, 0x01F5
 68a:	80 34       	cpi	r24, 0x40	; 64
 68c:	d0 f4       	brcc	.+52     	; 0x6c2
	{
		UART0_RxBuffer[UART0_RxTail++]=c;
 68e:	80 91 f7 01 	lds	r24, 0x01F7
 692:	e8 2f       	mov	r30, r24
 694:	ff 27       	eor	r31, r31
 696:	eb 54       	subi	r30, 0x4B	; 75
 698:	fe 4f       	sbci	r31, 0xFE	; 254
 69a:	90 83       	st	Z, r25
 69c:	8f 5f       	subi	r24, 0xFF	; 255
 69e:	80 93 f7 01 	sts	0x01F7, r24
		if(UART0_RxTail>=UART0_RX_BUFFER_SIZE)
 6a2:	80 91 f7 01 	lds	r24, 0x01F7
 6a6:	80 34       	cpi	r24, 0x40	; 64
 6a8:	10 f0       	brcs	.+4      	; 0x6ae
			UART0_RxTail=0;
 6aa:	10 92 f7 01 	sts	0x01F7, r1
		UART0_RxSize++;
 6ae:	80 91 f5 01 	lds	r24, 0x01F5
 6b2:	8f 5f       	subi	r24, 0xFF	; 255
 6b4:	80 93 f5 01 	sts	0x01F5, r24
		if(UART0_RxSize>=UART0_RX_FLOW_SIZE)
 6b8:	80 91 f5 01 	lds	r24, 0x01F5
 6bc:	8c 33       	cpi	r24, 0x3C	; 60
 6be:	08 f0       	brcs	.+2      	; 0x6c2
		{
			// Turn Cleart to send off    
			CTS0_OFF();
 6c0:	1a 9a       	sbi	0x03, 2	; 3
		}
	}
}
 6c2:	ff 91       	pop	r31
 6c4:	ef 91       	pop	r30
 6c6:	9f 91       	pop	r25
 6c8:	8f 91       	pop	r24
 6ca:	0f 90       	pop	r0
 6cc:	0f be       	out	0x3f, r0	; 63
 6ce:	0f 90       	pop	r0
 6d0:	1f 90       	pop	r1
 6d2:	18 95       	reti

000006d4 <__vector_20>:

/* UART0 Receive Complete Interrupt Function */
SIGNAL(SIG_UART0_TRANS)      
{    
 6d4:	1f 92       	push	r1
 6d6:	0f 92       	push	r0
 6d8:	0f b6       	in	r0, 0x3f	; 63
 6da:	0f 92       	push	r0
 6dc:	11 24       	eor	r1, r1
 6de:	8f 93       	push	r24
    UART0_Ready = ((U8)0x1);
 6e0:	81 e0       	ldi	r24, 0x01	; 1
 6e2:	80 93 f6 01 	sts	0x01F6, r24
}
 6e6:	8f 91       	pop	r24
 6e8:	0f 90       	pop	r0
 6ea:	0f be       	out	0x3f, r0	; 63
 6ec:	0f 90       	pop	r0
 6ee:	1f 90       	pop	r1
 6f0:	18 95       	reti

000006f2 <UART0_Init>:

void 
UART0_Init(U16 Baud_Rate )
{
 6f2:	9c 01       	movw	r18, r24
	//
	// Init Rx FIFO
	//    
	UART0_RxSize=UART0_RxHead=UART0_RxTail=0;
 6f4:	10 92 f7 01 	sts	0x01F7, r1
 6f8:	80 91 f7 01 	lds	r24, 0x01F7
 6fc:	80 93 b4 01 	sts	0x01B4, r24
 700:	80 91 b4 01 	lds	r24, 0x01B4
 704:	80 93 f5 01 	sts	0x01F5, r24
    UART0_Ready = ((U8)0x1);
 708:	81 e0       	ldi	r24, 0x01	; 1
 70a:	80 93 f6 01 	sts	0x01F6, r24
//    pUART0_Buffer = ((U8*)0x0);
//    UART0_PgmMem = ((U8)0x0);
//    UART0_CRLF = ((U8)0x0);

    /* enable RxD/TxD and interrupts */
    outp( (BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN)), UCSR0B );
 70e:	88 ed       	ldi	r24, 0xD8	; 216
 710:	8a b9       	out	0x0a, r24	; 10

    /* set baud rate */
    outp( Baud_Rate, UBRR0L ); 
 712:	29 b9       	out	0x09, r18	; 9
	outp( Baud_Rate >> 8, UBRR0H);
 714:	83 2f       	mov	r24, r19
 716:	99 27       	eor	r25, r25
 718:	80 93 90 00 	sts	0x0090, r24
    
    /* Set Request to send on */ 
    /* Data Set Ready on */
    CTS0_ON();
 71c:	1a 98       	cbi	0x03, 2	; 3
    DSR0_ON();
 71e:	1b 98       	cbi	0x03, 3	; 3
#ifdef DEBUG_LV3
	CONSOLE_puts("console baud rate ");
	printShort(Baud_Rate);
	CONSOLE_puts(CRLF);
#endif
}
 720:	08 95       	ret

00000722 <wait>:


wait()
{
//static d;

	if(!RTS0())
 722:	0e 9b       	sbis	0x01, 6	; 1
 724:	02 c0       	rjmp	.+4      	; 0x72a
		DCDI_OFF();
 726:	c7 98       	cbi	0x18, 7	; 24
 728:	01 c0       	rjmp	.+2      	; 0x72c
	else
		DCDI_ON();
 72a:	c7 9a       	sbi	0x18, 7	; 24

	if(!DTR0())
 72c:	0d 9b       	sbis	0x01, 5	; 1
 72e:	02 c0       	rjmp	.+4      	; 0x734
		DTRI_OFF();	
 730:	c6 98       	cbi	0x18, 6	; 24
	else
		DTRI_ON();	


	//putch(".");

/*	if(d++ & 0x8)
	{
		//CTS_ON();
		DCDI_ON();
`		}
	else
	{
		//CTS_OFF();
		DCDI_OFF();
	}	
*/
}
 732:	08 95       	ret
 734:	c6 9a       	sbi	0x18, 6	; 24
 736:	08 95       	ret
 738:	08 95       	ret

0000073a <getch>:


char 
getch( void ) 
{   
U8	c;
	    /* wait for UART to indicate that a character has been received */
    	while( !UART0_RxSize);
 73a:	80 91 f5 01 	lds	r24, 0x01F5
 73e:	88 23       	and	r24, r24
 740:	e1 f3       	breq	.-8      	; 0x73a
    
	    /* get byte from fifo */
		c=UART0_RxBuffer[UART0_RxHead++];
 742:	80 91 b4 01 	lds	r24, 0x01B4
 746:	e8 2f       	mov	r30, r24
 748:	ff 27       	eor	r31, r31
 74a:	eb 54       	subi	r30, 0x4B	; 75
 74c:	fe 4f       	sbci	r31, 0xFE	; 254
 74e:	e0 81       	ld	r30, Z
 750:	8f 5f       	subi	r24, 0xFF	; 255
 752:	80 93 b4 01 	sts	0x01B4, r24
		if(UART0_RxHead >= UART0_RX_BUFFER_SIZE)
 756:	80 91 b4 01 	lds	r24, 0x01B4
 75a:	80 34       	cpi	r24, 0x40	; 64
 75c:	10 f0       	brcs	.+4      	; 0x762
			UART0_RxHead=0;
 75e:	10 92 b4 01 	sts	0x01B4, r1
	
		/* Decerment number of bytes in fifo, if we are under flow size make sure flow control is off   */
		/* this is a critical section, we don't want off flow control after the interrupt has turned    */
		/* it on after we've updated the UART_RxSize, so protect this section 							*/

		cli(); 
 762:	f8 94       	cli
		UART0_RxSize--;
 764:	80 91 f5 01 	lds	r24, 0x01F5
 768:	81 50       	subi	r24, 0x01	; 1
 76a:	80 93 f5 01 	sts	0x01F5, r24
		if(UART0_RxSize < UART0_RX_FLOW_SIZE)
 76e:	80 91 f5 01 	lds	r24, 0x01F5
 772:	8c 33       	cpi	r24, 0x3C	; 60
 774:	08 f4       	brcc	.+2      	; 0x778
		{
			// Turn Request to Send on.
	        CTS0_ON();				
 776:	1a 98       	cbi	0x03, 2	; 3
		}    
	    // End critical section
		sei();
 778:	78 94       	sei
	//
	// Return char
	return c;
 77a:	8e 2f       	mov	r24, r30
 77c:	99 27       	eor	r25, r25
}
 77e:	08 95       	ret

00000780 <putch>:


/* putch(char c) - putchar for UART0 */
char 
putch( char c )
/* blocks */
{
 780:	cf 93       	push	r28
 782:	c8 2f       	mov	r28, r24
    /* wait for UART to become available and we are not throttled by flow control */

	TXI0_ON();
 784:	c4 9a       	sbi	0x18, 4	; 24

	if(mm.SerialConfig & CONSOLE_RTS)
 786:	80 91 02 02 	lds	r24, 0x0202
 78a:	82 ff       	sbrs	r24, 2
 78c:	0f c0       	rjmp	.+30     	; 0x7ac
		while((!UART0_Ready) || !RTS0()) wait();		/* RTS not working on hyperterm? */
 78e:	80 91 f6 01 	lds	r24, 0x01F6
 792:	88 23       	and	r24, r24
 794:	11 f0       	breq	.+4      	; 0x79a
 796:	0e 9b       	sbis	0x01, 6	; 1
 798:	13 c0       	rjmp	.+38     	; 0x7c0
 79a:	0e 94 91 03 	call	0x722
 79e:	80 91 f6 01 	lds	r24, 0x01F6
 7a2:	88 23       	and	r24, r24
 7a4:	d1 f3       	breq	.-12     	; 0x79a
 7a6:	0e 99       	sbic	0x01, 6	; 1
 7a8:	f8 cf       	rjmp	.-16     	; 0x79a
 7aa:	0a c0       	rjmp	.+20     	; 0x7c0
	else
		while( !UART0_Ready ) wait();
 7ac:	80 91 f6 01 	lds	r24, 0x01F6
 7b0:	88 23       	and	r24, r24
 7b2:	31 f4       	brne	.+12     	; 0x7c0
 7b4:	0e 94 91 03 	call	0x722
 7b8:	80 91 f6 01 	lds	r24, 0x01F6
 7bc:	88 23       	and	r24, r24
 7be:	d1 f3       	breq	.-12     	; 0x7b4

    UART0_Ready = 0;
 7c0:	10 92 f6 01 	sts	0x01F6, r1
	
    /* Send character */
    outp( c, UDR0 );
 7c4:	cc b9       	out	0x0c, r28	; 12

    return c;
 7c6:	8c 2f       	mov	r24, r28
 7c8:	99 27       	eor	r25, r25
}
 7ca:	cf 91       	pop	r28
 7cc:	08 95       	ret

000007ce <CONSOLE_init>:
#endif

#ifdef WINDOWS
int
print_log_char(char c)
{
        static FILE *fp;
 
        if(!fp)
			if(NULL == (fp = fopen("unetserlog.txt", "a")) )
				return -1;
			else
				fprintf(fp,"\n\n--Log Started---\n");
  
        fprintf(fp, "%c", c);

        return 0;
}
#endif



void CONSOLE_init(U16 baud_rate)
{
#ifdef __AVR__
	UART0_Init(baud_rate);
 7ce:	0e 94 79 03 	call	0x6f2
#endif
}
 7d2:	08 95       	ret

000007d4 <CONSOLE_putch>:

void
CONSOLE_putch(char c)
{
#ifdef WINDOWS
		print_log_char(c);
#endif
	putch(c);
 7d4:	0e 94 c0 03 	call	0x780
}	
 7d8:	08 95       	ret

000007da <CONSOLE_getch>:

char
CONSOLE_getch()
{
	return(getch());
 7da:	0e 94 9d 03 	call	0x73a
 7de:	99 27       	eor	r25, r25
}
 7e0:	08 95       	ret

000007e2 <CONSOLE_kbhit>:

char
CONSOLE_kbhit()
{
	return(kbhit());
 7e2:	80 91 f5 01 	lds	r24, 0x01F5
 7e6:	99 27       	eor	r25, r25
}
 7e8:	08 95       	ret

000007ea <CONSOLE_cputs>:

//
// CONSOLE_cputs(buf) - this function prints out FLASH based memory strings
//
void
CONSOLE_cputs(char *buf)
{
 7ea:	cf 93       	push	r28
 7ec:	df 93       	push	r29
 7ee:	ec 01       	movw	r28, r24
#ifdef __AVR__
	while(PRG_RDB(buf))
 7f0:	fc 01       	movw	r30, r24
 7f2:	84 91       	lpm	r24, Z
 7f4:	88 23       	and	r24, r24
 7f6:	49 f0       	breq	.+18     	; 0x80a
	{
		CONSOLE_putch(PRG_RDB(buf++));
 7f8:	fe 01       	movw	r30, r28
 7fa:	21 96       	adiw	r28, 0x01	; 1
 7fc:	84 91       	lpm	r24, Z
 7fe:	0e 94 ea 03 	call	0x7d4
 802:	fe 01       	movw	r30, r28
 804:	84 91       	lpm	r24, Z
 806:	88 23       	and	r24, r24
 808:	b9 f7       	brne	.-18     	; 0x7f8
	}
#else
	CONSOLE_puts(buf);
#endif
}
 80a:	df 91       	pop	r29
 80c:	cf 91       	pop	r28
 80e:	08 95       	ret

00000810 <CONSOLE_puts>:

void
CONSOLE_puts(char *buf)
{
 810:	cf 93       	push	r28
 812:	df 93       	push	r29
 814:	ec 01       	movw	r28, r24
	if(buf!=0)
 816:	89 2b       	or	r24, r25
 818:	49 f0       	breq	.+18     	; 0x82c
	{
		while(*buf)
 81a:	88 81       	ld	r24, Y
 81c:	88 23       	and	r24, r24
 81e:	31 f0       	breq	.+12     	; 0x82c
			CONSOLE_putch(*buf++);
 820:	89 91       	ld	r24, Y+
 822:	0e 94 ea 03 	call	0x7d4
 826:	88 81       	ld	r24, Y
 828:	88 23       	and	r24, r24
 82a:	d1 f7       	brne	.-12     	; 0x820
	}
}
 82c:	df 91       	pop	r29
 82e:	cf 91       	pop	r28
 830:	08 95       	ret

00000832 <__vector_16>:


/* AVR Timer 0 overflow Signal */
SIGNAL(SIG_OVERFLOW0)
{   
 832:	1f 92       	push	r1
 834:	0f 92       	push	r0
 836:	0f b6       	in	r0, 0x3f	; 63
 838:	0f 92       	push	r0
 83a:	11 24       	eor	r1, r1
 83c:	8f 93       	push	r24
 83e:	9f 93       	push	r25
	/* incerment timer */
	TIMER_Counter++;
 840:	80 91 fb 01 	lds	r24, 0x01FB
 844:	8f 5f       	subi	r24, 0xFF	; 255
 846:	80 93 fb 01 	sts	0x01FB, r24
	TIMER_Tick++;
 84a:	80 91 f9 01 	lds	r24, 0x01F9
 84e:	90 91 fa 01 	lds	r25, 0x01FA
 852:	01 96       	adiw	r24, 0x01	; 1
 854:	90 93 fa 01 	sts	0x01FA, r25
 858:	80 93 f9 01 	sts	0x01F9, r24

	/* seconds need to be updated? */
	if(TIMER_Counter>TICKS_PER_SECOND)
 85c:	80 91 fb 01 	lds	r24, 0x01FB
 860:	89 34       	cpi	r24, 0x49	; 73
 862:	38 f0       	brcs	.+14     	; 0x872
	{
		TIMER_Second++;
 864:	80 91 f8 01 	lds	r24, 0x01F8
 868:	8f 5f       	subi	r24, 0xFF	; 255
 86a:	80 93 f8 01 	sts	0x01F8, r24
		TIMER_Counter=0;
 86e:	10 92 fb 01 	sts	0x01FB, r1
	}
	
	/* Reset Timer */
	outp((U8)(150/*-TICKS_PER_SECOND*/)/*TIMER_SELECT*/,TCNT0);
 872:	86 e9       	ldi	r24, 0x96	; 150
 874:	82 bf       	out	0x32, r24	; 50
	//outp((U8)TIMER_SELECT,TCNT0);

	/* turn off indicators */
	TXI0_OFF();
 876:	c4 98       	cbi	0x18, 4	; 24
	RXI0_OFF();
 878:	c5 98       	cbi	0x18, 5	; 24

}
 87a:	9f 91       	pop	r25
 87c:	8f 91       	pop	r24
 87e:	0f 90       	pop	r0
 880:	0f be       	out	0x3f, r0	; 63
 882:	0f 90       	pop	r0
 884:	1f 90       	pop	r1
 886:	18 95       	reti

00000888 <timer_set>:

#endif






void
timer_set(void)
{
	//printf("set timer\n");
	time_start=TIMER_Get_Second();
 888:	0e 94 82 04 	call	0x904
 88c:	90 93 a3 01 	sts	0x01A3, r25
 890:	80 93 a2 01 	sts	0x01A2, r24
	if(0==time_start)
 894:	00 97       	sbiw	r24, 0x00	; 0
 896:	29 f4       	brne	.+10     	; 0x8a2
		time_start++;
 898:	01 96       	adiw	r24, 0x01	; 1
 89a:	90 93 a3 01 	sts	0x01A3, r25
 89e:	80 93 a2 01 	sts	0x01A2, r24
}
 8a2:	08 95       	ret
 8a4:	08 95       	ret

000008a6 <timer_timeout>:

U8
timer_timeout(U16 timeout_val)
{
 8a6:	cf 93       	push	r28
 8a8:	df 93       	push	r29
 8aa:	ec 01       	movw	r28, r24
	if(0==time_start)
 8ac:	80 91 a2 01 	lds	r24, 0x01A2
 8b0:	90 91 a3 01 	lds	r25, 0x01A3
 8b4:	89 2b       	or	r24, r25
 8b6:	59 f0       	breq	.+22     	; 0x8ce
	{
		//DEBUG1("timerturned off\n");
		return 1;
	}
	if(timeout_val < (TIMER_Get_Second()-time_start))
 8b8:	0e 94 82 04 	call	0x904
 8bc:	20 91 a2 01 	lds	r18, 0x01A2
 8c0:	30 91 a3 01 	lds	r19, 0x01A3
 8c4:	82 1b       	sub	r24, r18
 8c6:	93 0b       	sbc	r25, r19
 8c8:	c8 17       	cp	r28, r24
 8ca:	d9 07       	cpc	r29, r25
 8cc:	18 f4       	brcc	.+6      	; 0x8d4
	{
		//printf("timeout %d  --  %d \n",timeout_val, TIMER_Get_Second()-time_start);
		if(mm.IMMConfig & PPP_DEBUG)
		{
			DEBUG1("timer timeout"CRLF);
		}
		return 1;
 8ce:	81 e0       	ldi	r24, 0x01	; 1
 8d0:	90 e0       	ldi	r25, 0x00	; 0
 8d2:	02 c0       	rjmp	.+4      	; 0x8d8
	}
	else
	{
		//printf("notimeout %d  --  %d \n",timeout_val, TIMER_Get_Second()-time_start);
		return 0;
 8d4:	80 e0       	ldi	r24, 0x00	; 0
 8d6:	90 e0       	ldi	r25, 0x00	; 0
	}
}
 8d8:	df 91       	pop	r29
 8da:	cf 91       	pop	r28
 8dc:	08 95       	ret

000008de <timer_expire>:

U8
timer_expire(void)
{
	///DEBUG1("turn off\n");
	time_start=0;
 8de:	10 92 a3 01 	sts	0x01A3, r1
 8e2:	10 92 a2 01 	sts	0x01A2, r1
	return(0);
}
 8e6:	80 e0       	ldi	r24, 0x00	; 0
 8e8:	90 e0       	ldi	r25, 0x00	; 0
 8ea:	08 95       	ret

000008ec <TIMER_Init>:


//#define TICKS_PER_SECOND    100
//U16 TIMER_Counter;
//U8  TIMER_Tick;
//U8  TIMER_Second;

//
// This function initilizes timer 0 on the Mega128 (and possibly other avr chips)
//
//
void 
TIMER_Init(void)
{
#ifdef __AVR__
	    /* enable TCNT0 overflow */
    outp((1<<TOIE0),TIMSK);
 8ec:	81 e0       	ldi	r24, 0x01	; 1
 8ee:	87 bf       	out	0x37, r24	; 55

    /* count with cpu clock/1024 */
    outp(0x07,TCCR0);
 8f0:	87 e0       	ldi	r24, 0x07	; 7
 8f2:	83 bf       	out	0x33, r24	; 51

    /* reset TCNT0 */
    outp((U8)(255-TICKS_PER_SECOND)/*TIMER_SELECT*/,TCNT0);
 8f4:	87 eb       	ldi	r24, 0xB7	; 183
 8f6:	82 bf       	out	0x32, r24	; 50
#endif
}
 8f8:	08 95       	ret

000008fa <TIMER_Get_Tick>:


U16
TIMER_Get_Tick()
{
#ifdef WINDOWS
	struct _timeb timebuffer;
	time_t			t;
	U16		ticks;
  
	_ftime( &timebuffer );
	time(&t);

	ticks=0;
	ticks=(U16)(t<<6);
	ticks=ticks + ((timebuffer.millitm  & 0xff)>>2);

	//printf("%d\n",ticks);

	return(ticks);
#else
	// AVR
	return(TIMER_Tick);
 8fa:	80 91 f9 01 	lds	r24, 0x01F9
 8fe:	90 91 fa 01 	lds	r25, 0x01FA
#endif   
}
 902:	08 95       	ret

00000904 <TIMER_Get_Second>:

U16
TIMER_Get_Second()
{
#ifdef WINDOWS
	return(get_seconds());
#else
	// AVR
	return(TIMER_Second);
 904:	80 91 f8 01 	lds	r24, 0x01F8
 908:	99 27       	eor	r25, r25
#endif
} 
 90a:	08 95       	ret

0000090c <TIMER_Wait_Tick>:

void
TIMER_Wait_Tick(U16 wait_ticks)
{     
 90c:	0f 93       	push	r16
 90e:	1f 93       	push	r17
 910:	cf 93       	push	r28
 912:	df 93       	push	r29
 914:	8c 01       	movw	r16, r24
U16	tick_start;

	tick_start=TIMER_Get_Tick(); 
 916:	0e 94 7d 04 	call	0x8fa
 91a:	ec 01       	movw	r28, r24
    while(1)	
    {   
		//poll_serial();
	   	if(abs(TIMER_Get_Tick()-tick_start) > wait_ticks )	
 91c:	0e 94 7d 04 	call	0x8fa
 920:	8c 1b       	sub	r24, r28
 922:	9d 0b       	sbc	r25, r29
 924:	97 ff       	sbrs	r25, 7
 926:	03 c0       	rjmp	.+6      	; 0x92e
 928:	90 95       	com	r25
 92a:	81 95       	neg	r24
 92c:	9f 4f       	sbci	r25, 0xFF	; 255
 92e:	08 17       	cp	r16, r24
 930:	19 07       	cpc	r17, r25
 932:	a0 f7       	brcc	.-24     	; 0x91c
			break;
	}
}      
 934:	df 91       	pop	r29
 936:	cf 91       	pop	r28
 938:	1f 91       	pop	r17
 93a:	0f 91       	pop	r16
 93c:	08 95       	ret

0000093e <delay_us>:

void
delay_us(U16 us)
{
	TIMER_Wait_Tick(us);
 93e:	0e 94 86 04 	call	0x90c
}
 942:	08 95       	ret

00000944 <global_init>:
    \param cmd	0=load default	1=load eeprom
*/
U8
global_init(U8 cmd)
{
 944:	ef 92       	push	r14
 946:	ff 92       	push	r15
 948:	0f 93       	push	r16
 94a:	1f 93       	push	r17
 94c:	cf 93       	push	r28
 94e:	df 93       	push	r29
 950:	08 2f       	mov	r16, r24
U8	count,*ptr=(U8 *)&mm;

#ifdef __AVR__
	if(1==cmd)
 952:	81 30       	cpi	r24, 0x01	; 1
 954:	d1 f4       	brne	.+52     	; 0x98a
	{
		// Try to load eeprom, 0xa5 is the flag that means eeprom is good.
		// uint8_t 	eeprom_read_byte (const uint8_t *addr)
		if((cmd) && (0xa5==eeprom_read_byte(0)))
 956:	80 e0       	ldi	r24, 0x00	; 0
 958:	90 e0       	ldi	r25, 0x00	; 0
 95a:	0e 94 8c 07 	call	0xf18
 95e:	85 3a       	cpi	r24, 0xA5	; 165
 960:	99 f4       	brne	.+38     	; 0x988
		{
		//	DEBUG1("Load EEPROM"CRLF);
			// Load the config from the eeprom
			for(count=0;count<sizeof(MEMMAP)-7;count++)
 962:	10 e0       	ldi	r17, 0x00	; 0
 964:	9c ef       	ldi	r25, 0xFC	; 252
 966:	e9 2e       	mov	r14, r25
 968:	91 e0       	ldi	r25, 0x01	; 1
 96a:	f9 2e       	mov	r15, r25
 96c:	c0 e0       	ldi	r28, 0x00	; 0
 96e:	d0 e0       	ldi	r29, 0x00	; 0
				ptr[count]=eeprom_read_byte((count+0xa));
 970:	2a 96       	adiw	r28, 0x0a	; 10
 972:	ce 01       	movw	r24, r28
 974:	0e 94 8c 07 	call	0xf18
 978:	f7 01       	movw	r30, r14
 97a:	81 93       	st	Z+, r24
 97c:	7f 01       	movw	r14, r30
 97e:	1f 5f       	subi	r17, 0xFF	; 255
 980:	29 97       	sbiw	r28, 0x09	; 9
 982:	1a 37       	cpi	r17, 0x7A	; 122
 984:	a8 f3       	brcs	.-22     	; 0x970
 986:	01 c0       	rjmp	.+2      	; 0x98a
		}
		else
		{
		//	DEBUG1("EEPROM not valid ");
			// eeprom is not valid, load defaults
			cmd=0;
 988:	00 e0       	ldi	r16, 0x00	; 0
		}
	}
	if(2==cmd)
 98a:	02 30       	cpi	r16, 0x02	; 2
 98c:	b9 f4       	brne	.+46     	; 0x9bc
	{
		// Validate the eeprom
		eeprom_write_byte (0,0xa5);
 98e:	65 ea       	ldi	r22, 0xA5	; 165
 990:	80 e0       	ldi	r24, 0x00	; 0
 992:	90 e0       	ldi	r25, 0x00	; 0
 994:	0e 94 94 07 	call	0xf28
		//
		for(count=0;count<sizeof(MEMMAP)-7;count++)
 998:	10 e0       	ldi	r17, 0x00	; 0
 99a:	8c ef       	ldi	r24, 0xFC	; 252
 99c:	e8 2e       	mov	r14, r24
 99e:	81 e0       	ldi	r24, 0x01	; 1
 9a0:	f8 2e       	mov	r15, r24
 9a2:	c0 e0       	ldi	r28, 0x00	; 0
 9a4:	d0 e0       	ldi	r29, 0x00	; 0
			eeprom_write_byte((count+0xa),ptr[count]);
 9a6:	2a 96       	adiw	r28, 0x0a	; 10
 9a8:	f7 01       	movw	r30, r14
 9aa:	61 91       	ld	r22, Z+
 9ac:	7f 01       	movw	r14, r30
 9ae:	ce 01       	movw	r24, r28
 9b0:	0e 94 94 07 	call	0xf28
 9b4:	1f 5f       	subi	r17, 0xFF	; 255
 9b6:	29 97       	sbiw	r28, 0x09	; 9
 9b8:	1a 37       	cpi	r17, 0x7A	; 122
 9ba:	a8 f3       	brcs	.-22     	; 0x9a6

	}
#else
	cmd=0;
#endif
	if(0==cmd)
 9bc:	00 23       	and	r16, r16
 9be:	49 f4       	brne	.+18     	; 0x9d2
	{
		// 
		// Set defaults
		//
		//DEBUG1("Load Defaults"CRLF);
#ifdef __AVR__
		mm.IMMConfig					= BOOT_BANNER | ECHO_CMD | ECHO_STREAM | RESULT ;
 9c0:	87 e2       	ldi	r24, 0x27	; 39
 9c2:	80 93 fc 01 	sts	0x01FC, r24
#else
		mm.IMMConfig					= BOOT_BANNER | PPP_DEBUG | ECHO_CMD | ECHO_STREAM | RESULT ;		
#endif
		mm.escapeChar					= '+';
 9c6:	8b e2       	ldi	r24, 0x2B	; 43
 9c8:	80 93 fd 01 	sts	0x01FD, r24
//		mm.escape_timeout				= ESCAPE_TIMEOUT;
//		mm.TCPStreamTickTime			= 200;		
//		mm.UDPStreamTickTime			= 200;
//		mm.SerialConfig					= 0;							// serial config
//		mm.ModemBaud					= MODEM_BAUD_STATIC;			// ModemBaudRate
		mm.ConsoleBaud					= CONSOLE_BAUD_STATIC;			// ConsoleBaudRate
 9cc:	87 e1       	ldi	r24, 0x17	; 23
 9ce:	80 93 04 02 	sts	0x0204, r24
		
//		mm.DialTimeout					= 30;	// 30 seconds.
//		mm.ppp_connect_timeout			= 15;	// 30 seconds.
//		mm.ppp_tx_accm					= 0;	// don't escape anything

//		mm.ip_ttl						= IP_TTL_DEFAULT; 
//		mm.ip_tos						= IP_TOS_DEFAULT;
		
//		mm.tcp_connect_timeout			= TCP_CONNECT_TIMOUT;
//		mm.tcp_retransmit_timeout		= TCP_TIMETOUT;
//		mm.dns_timeout					= DNS_REPLY_WAIT_TIME;	
//		mm.ppp_rx_accm					= 0;
	}

	return(cmd);
 9d2:	80 2f       	mov	r24, r16
 9d4:	99 27       	eor	r25, r25
}
 9d6:	df 91       	pop	r29
 9d8:	cf 91       	pop	r28
 9da:	1f 91       	pop	r17
 9dc:	0f 91       	pop	r16
 9de:	ff 90       	pop	r15
 9e0:	ef 90       	pop	r14
 9e2:	08 95       	ret

000009e4 <spiInit>:
	sbi(DDRB, 2);	// set MOSI as output
	sbi(DDRB, 0);	// SS must be output for Master mode to work
#elif __AVR_ATmega64__
		// setup SPI I/O pins
	sbi(PORTB, 1);	// set SCK hi
 9e4:	c1 9a       	sbi	0x18, 1	; 24
	sbi(DDRB, 1);	// set SCK as output
 9e6:	b9 9a       	sbi	0x17, 1	; 23
	cbi(DDRB, 3);	// set MISO as input
 9e8:	bb 98       	cbi	0x17, 3	; 23
	sbi(DDRB, 2);	// set MOSI as output
 9ea:	ba 9a       	sbi	0x17, 2	; 23
	sbi(DDRB, 0);	// SS must be output for Master mode to work
 9ec:	b8 9a       	sbi	0x17, 0	; 23
#elif __AVR_ATmega8__
    // setup SPI I/O pins
    sbi(PORTB, 5);  // set SCK hi
    sbi(DDRB, 5);   // set SCK as output
    cbi(DDRB, 4);   // set MISO as input
    sbi(DDRB, 3);   // set MOSI as output
    sbi(DDRB, 2);   // SS must be output for Master mode to work
#else
	// setup SPI I/O pins
	sbi(PORTB, 7);	// set SCK hi
	sbi(DDRB, 7);	// set SCK as output
	cbi(DDRB, 6);	// set MISO as input
	sbi(DDRB, 5);	// set MOSI as output
	sbi(DDRB, 4);	// SS must be output for Master mode to work
#endif
	
	// setup SPI interface :
	// master mode
	sbi(SPCR, MSTR);
 9ee:	6c 9a       	sbi	0x0d, 4	; 13
	// clock = f/4
//	cbi(SPCR, SPR0);
//	cbi(SPCR, SPR1);
	// clock = f/16
	cbi(SPCR, SPR0);
 9f0:	68 98       	cbi	0x0d, 0	; 13
	sbi(SPCR, SPR1);
 9f2:	69 9a       	sbi	0x0d, 1	; 13
	// select clock phase positive-going in middle of data
	cbi(SPCR, CPOL);
 9f4:	6b 98       	cbi	0x0d, 3	; 13
	// Data order MSB first
	cbi(SPCR,DORD);
 9f6:	6d 98       	cbi	0x0d, 5	; 13
	// enable SPI
	sbi(SPCR, SPE);
 9f8:	6e 9a       	sbi	0x0d, 6	; 13
		
	
	// some other possible configs
	//outp((1<<MSTR)|(1<<SPE)|(1<<SPR0), SPCR );
	//outp((1<<CPHA)|(1<<CPOL)|(1<<MSTR)|(1<<SPE)|(1<<SPR0)|(1<<SPR1), SPCR );
	//outp((1<<CPHA)|(1<<MSTR)|(1<<SPE)|(1<<SPR0), SPCR );
	
	// clear status
	inb(SPSR);
 9fa:	8e b1       	in	r24, 0x0e	; 14
	spiTransferComplete = TRUE;
 9fc:	8f ef       	ldi	r24, 0xFF	; 255
 9fe:	80 93 7d 02 	sts	0x027D, r24

	// enable SPI interrupt
	#ifdef SPI_USEINT
	sbi(SPCR, SPIE);
	#endif
}
 a02:	08 95       	ret

00000a04 <spiSendByte>:
/*
void spiSetBitrate(u08 spr)
{
	outb(SPCR, (inb(SPCR) & ((1<<SPR0)|(1<<SPR1))) | (spr&((1<<SPR0)|(1<<SPR1)))));
}
*/
void spiSendByte(U8 data)
{
	// send a byte over SPI and ignore reply
	#ifdef SPI_USEINT
		while(!spiTransferComplete);
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
 a04:	77 9b       	sbis	0x0e, 7	; 14
 a06:	fe cf       	rjmp	.-4      	; 0xa04
	#endif

	spiTransferComplete = FALSE;
 a08:	10 92 7d 02 	sts	0x027D, r1
	outb(SPDR, data);
 a0c:	8f b9       	out	0x0f, r24	; 15
}
 a0e:	08 95       	ret

00000a10 <spiTransferByte>:

U8 spiTransferByte(U8 data)
{
/*	// make sure interface is idle
	#ifdef SPI_USEINT
		while(!spiTransferComplete);
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
	#endif
*/
	// send the given data
	spiTransferComplete = FALSE;
 a10:	10 92 7d 02 	sts	0x027D, r1
	outb(SPDR, data);
 a14:	8f b9       	out	0x0f, r24	; 15

	// wait for transfer to complete
	#ifdef SPI_USEINT
		while(!spiTransferComplete);
	#else
		while(!(inb(SPSR) & (1<<SPIF)));
 a16:	77 9b       	sbis	0x0e, 7	; 14
 a18:	fe cf       	rjmp	.-4      	; 0xa16
		// *** reading of the SPSR and SPDR are crucial
		// *** to the clearing of the SPIF flag
		// *** in non-interrupt mode
		//inb(SPDR);
		// set flag
		spiTransferComplete = TRUE;
 a1a:	8f ef       	ldi	r24, 0xFF	; 255
 a1c:	80 93 7d 02 	sts	0x027D, r24
	#endif
	// return the received data
	return inb(SPDR);
 a20:	8f b1       	in	r24, 0x0f	; 15
 a22:	99 27       	eor	r25, r25
}
 a24:	08 95       	ret

00000a26 <spiTransferWord>:

U16 spiTransferWord(U16 data)
{
 a26:	ef 92       	push	r14
 a28:	ff 92       	push	r15
 a2a:	0f 93       	push	r16
 a2c:	1f 93       	push	r17
 a2e:	7c 01       	movw	r14, r24
	U16 rxData = 0;

	// send MS byte of given data
	rxData = (spiTransferByte((data>>8) & 0x00FF))<<8;
 a30:	89 2f       	mov	r24, r25
 a32:	99 27       	eor	r25, r25
 a34:	0e 94 08 05 	call	0xa10
 a38:	99 27       	eor	r25, r25
 a3a:	18 2f       	mov	r17, r24
 a3c:	00 27       	eor	r16, r16
	// send LS byte of given data
	rxData |= (spiTransferByte(data & 0x00FF));
 a3e:	8e 2d       	mov	r24, r14
 a40:	0e 94 08 05 	call	0xa10
 a44:	99 27       	eor	r25, r25
 a46:	08 2b       	or	r16, r24
 a48:	19 2b       	or	r17, r25

	// return the received data
	return rxData;
}
 a4a:	c8 01       	movw	r24, r16
 a4c:	1f 91       	pop	r17
 a4e:	0f 91       	pop	r16
 a50:	ff 90       	pop	r15
 a52:	ef 90       	pop	r14
 a54:	08 95       	ret

00000a56 <nicInit>:
u16 NextPacketPtr;

void nicInit(void)
{
	enc28j60Init();
 a56:	0e 94 57 06 	call	0xcae
}
 a5a:	08 95       	ret

00000a5c <nicSend>:

void nicSend(unsigned int len, unsigned char* packet)
{
	enc28j60PacketSend(len, packet);
 a5c:	0e 94 e5 06 	call	0xdca
}
 a60:	08 95       	ret

00000a62 <nicPoll>:

unsigned int nicPoll(unsigned int maxlen, unsigned char* packet)
{
	return enc28j60PacketReceive(maxlen, packet);
 a62:	0e 94 10 07 	call	0xe20
}
 a66:	08 95       	ret

00000a68 <nicGetMacAddress>:

void nicGetMacAddress(u08* macaddr)
{
 a68:	0f 93       	push	r16
 a6a:	1f 93       	push	r17
 a6c:	8c 01       	movw	r16, r24
	// read MAC address registers
	// NOTE: MAC address in ENC28J60 is byte-backward
	*macaddr++ = enc28j60Read(MAADR5);
 a6e:	84 ee       	ldi	r24, 0xE4	; 228
 a70:	0e 94 03 06 	call	0xc06
 a74:	f8 01       	movw	r30, r16
 a76:	81 93       	st	Z+, r24
 a78:	8f 01       	movw	r16, r30
	*macaddr++ = enc28j60Read(MAADR4);
 a7a:	85 ee       	ldi	r24, 0xE5	; 229
 a7c:	0e 94 03 06 	call	0xc06
 a80:	f8 01       	movw	r30, r16
 a82:	81 93       	st	Z+, r24
 a84:	8f 01       	movw	r16, r30
	*macaddr++ = enc28j60Read(MAADR3);
 a86:	82 ee       	ldi	r24, 0xE2	; 226
 a88:	0e 94 03 06 	call	0xc06
 a8c:	f8 01       	movw	r30, r16
 a8e:	81 93       	st	Z+, r24
 a90:	8f 01       	movw	r16, r30
	*macaddr++ = enc28j60Read(MAADR2);
 a92:	83 ee       	ldi	r24, 0xE3	; 227
 a94:	0e 94 03 06 	call	0xc06
 a98:	f8 01       	movw	r30, r16
 a9a:	81 93       	st	Z+, r24
 a9c:	8f 01       	movw	r16, r30
	*macaddr++ = enc28j60Read(MAADR1);
 a9e:	80 ee       	ldi	r24, 0xE0	; 224
 aa0:	0e 94 03 06 	call	0xc06
 aa4:	f8 01       	movw	r30, r16
 aa6:	81 93       	st	Z+, r24
 aa8:	8f 01       	movw	r16, r30
	*macaddr++ = enc28j60Read(MAADR0);
 aaa:	81 ee       	ldi	r24, 0xE1	; 225
 aac:	0e 94 03 06 	call	0xc06
 ab0:	f8 01       	movw	r30, r16
 ab2:	80 83       	st	Z, r24
}
 ab4:	1f 91       	pop	r17
 ab6:	0f 91       	pop	r16
 ab8:	08 95       	ret

00000aba <nicSetMacAddress>:

void nicSetMacAddress(u08* macaddr)
{
 aba:	0f 93       	push	r16
 abc:	1f 93       	push	r17
	// write MAC address
	// NOTE: MAC address in ENC28J60 is byte-backward
	enc28j60Write(MAADR5, *macaddr++);
 abe:	fc 01       	movw	r30, r24
 ac0:	81 91       	ld	r24, Z+
 ac2:	8f 01       	movw	r16, r30
 ac4:	68 2f       	mov	r22, r24
 ac6:	84 ee       	ldi	r24, 0xE4	; 228
 ac8:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR4, *macaddr++);
 acc:	f8 01       	movw	r30, r16
 ace:	81 91       	ld	r24, Z+
 ad0:	8f 01       	movw	r16, r30
 ad2:	68 2f       	mov	r22, r24
 ad4:	85 ee       	ldi	r24, 0xE5	; 229
 ad6:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR3, *macaddr++);
 ada:	f8 01       	movw	r30, r16
 adc:	81 91       	ld	r24, Z+
 ade:	8f 01       	movw	r16, r30
 ae0:	68 2f       	mov	r22, r24
 ae2:	82 ee       	ldi	r24, 0xE2	; 226
 ae4:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR2, *macaddr++);
 ae8:	f8 01       	movw	r30, r16
 aea:	81 91       	ld	r24, Z+
 aec:	8f 01       	movw	r16, r30
 aee:	68 2f       	mov	r22, r24
 af0:	83 ee       	ldi	r24, 0xE3	; 227
 af2:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR1, *macaddr++);
 af6:	f8 01       	movw	r30, r16
 af8:	81 91       	ld	r24, Z+
 afa:	8f 01       	movw	r16, r30
 afc:	68 2f       	mov	r22, r24
 afe:	80 ee       	ldi	r24, 0xE0	; 224
 b00:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR0, *macaddr++);
 b04:	f8 01       	movw	r30, r16
 b06:	80 81       	ld	r24, Z
 b08:	68 2f       	mov	r22, r24
 b0a:	81 ee       	ldi	r24, 0xE1	; 225
 b0c:	0e 94 0e 06 	call	0xc1c
}
 b10:	1f 91       	pop	r17
 b12:	0f 91       	pop	r16
 b14:	08 95       	ret

00000b16 <enc28j60ReadOp>:

void nicRegDump(void)
{
	enc28j60RegDump();
}

/*
void ax88796SetupPorts(void)
{
#if NIC_CONNECTION == MEMORY_MAPPED
	// enable external SRAM interface - no wait states
	sbi(MCUCR, SRE);
//	sbi(MCUCR, SRW10);
//	sbi(XMCRA, SRW00);
//	sbi(XMCRA, SRW01);
//	sbi(XMCRA, SRW11);
#else
	// set address port to output
	AX88796_ADDRESS_DDR = AX88796_ADDRESS_MASK;
    
	// set data port to input with pull-ups
	AX88796_DATA_DDR = 0x00;
	AX88796_DATA_PORT = 0xFF;

	// initialize the control port read and write pins to de-asserted
	sbi( AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN );
	sbi( AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN );
	// set the read and write pins to output
	sbi( AX88796_CONTROL_DDR, AX88796_CONTROL_READPIN );
	sbi( AX88796_CONTROL_DDR, AX88796_CONTROL_WRITEPIN );
#endif
	// set reset pin to output
	sbi( AX88796_RESET_DDR, AX88796_RESET_PIN );
}
*/

u08 enc28j60ReadOp(u08 op, u08 address)
{
 b16:	98 2f       	mov	r25, r24
	u08 data;
   
	// assert CS
	ENC28J60_CONTROL_PORT &= ~(1<<ENC28J60_CONTROL_CS);
 b18:	c0 98       	cbi	0x18, 0	; 24
	
	// issue read command
	SPDR = op | (address & ADDR_MASK);
 b1a:	86 2f       	mov	r24, r22
 b1c:	8f 71       	andi	r24, 0x1F	; 31
 b1e:	89 2b       	or	r24, r25
 b20:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));
 b22:	77 9b       	sbis	0x0e, 7	; 14
 b24:	fe cf       	rjmp	.-4      	; 0xb22
	// read data
	SPDR = 0x00;
 b26:	1f b8       	out	0x0f, r1	; 15
	while(!(SPSR & (1<<SPIF)));
 b28:	77 9b       	sbis	0x0e, 7	; 14
 b2a:	fe cf       	rjmp	.-4      	; 0xb28
	// do dummy read if needed
	if(address & 0x80)
 b2c:	67 ff       	sbrs	r22, 7
 b2e:	03 c0       	rjmp	.+6      	; 0xb36
	{
		SPDR = 0x00;
 b30:	1f b8       	out	0x0f, r1	; 15
		while(!(inb(SPSR) & (1<<SPIF)));
 b32:	77 9b       	sbis	0x0e, 7	; 14
 b34:	fe cf       	rjmp	.-4      	; 0xb32
	}
	data = SPDR;
 b36:	8f b1       	in	r24, 0x0f	; 15
	
	// release CS
	ENC28J60_CONTROL_PORT |= (1<<ENC28J60_CONTROL_CS);
 b38:	c0 9a       	sbi	0x18, 0	; 24

	return data;
 b3a:	99 27       	eor	r25, r25
}
 b3c:	08 95       	ret

00000b3e <enc28j60WriteOp>:

void enc28j60WriteOp(u08 op, u08 address, u08 data)
{
 b3e:	98 2f       	mov	r25, r24
 b40:	86 2f       	mov	r24, r22
	// assert CS
	ENC28J60_CONTROL_PORT &= ~(1<<ENC28J60_CONTROL_CS);
 b42:	c0 98       	cbi	0x18, 0	; 24

	// issue write command
	SPDR = op | (address & ADDR_MASK);
 b44:	8f 71       	andi	r24, 0x1F	; 31
 b46:	98 2b       	or	r25, r24
 b48:	9f b9       	out	0x0f, r25	; 15
	while(!(SPSR & (1<<SPIF)));
 b4a:	77 9b       	sbis	0x0e, 7	; 14
 b4c:	fe cf       	rjmp	.-4      	; 0xb4a
	// write data
	SPDR = data;
 b4e:	4f b9       	out	0x0f, r20	; 15
	while(!(SPSR & (1<<SPIF)));
 b50:	77 9b       	sbis	0x0e, 7	; 14
 b52:	fe cf       	rjmp	.-4      	; 0xb50

	// release CS
	ENC28J60_CONTROL_PORT |= (1<<ENC28J60_CONTROL_CS);
 b54:	c0 9a       	sbi	0x18, 0	; 24
}
 b56:	08 95       	ret

00000b58 <enc28j60ReadBuffer>:

void enc28j60ReadBuffer(u16 len, u08* data)
{
 b58:	9c 01       	movw	r18, r24
 b5a:	fb 01       	movw	r30, r22
	// assert CS
	ENC28J60_CONTROL_PORT &= ~(1<<ENC28J60_CONTROL_CS);
 b5c:	c0 98       	cbi	0x18, 0	; 24
	
	// issue read command
	SPDR = ENC28J60_READ_BUF_MEM;
 b5e:	8a e3       	ldi	r24, 0x3A	; 58
 b60:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));
 b62:	77 9b       	sbis	0x0e, 7	; 14
 b64:	fe cf       	rjmp	.-4      	; 0xb62
	while(len--)
 b66:	21 50       	subi	r18, 0x01	; 1
 b68:	30 40       	sbci	r19, 0x00	; 0
 b6a:	8f ef       	ldi	r24, 0xFF	; 255
 b6c:	2f 3f       	cpi	r18, 0xFF	; 255
 b6e:	38 07       	cpc	r19, r24
 b70:	59 f0       	breq	.+22     	; 0xb88
	{
		// read data
		SPDR = 0x00;
 b72:	1f b8       	out	0x0f, r1	; 15
		while(!(SPSR & (1<<SPIF)));
 b74:	77 9b       	sbis	0x0e, 7	; 14
 b76:	fe cf       	rjmp	.-4      	; 0xb74
		*data++ = SPDR;
 b78:	8f b1       	in	r24, 0x0f	; 15
 b7a:	81 93       	st	Z+, r24
 b7c:	21 50       	subi	r18, 0x01	; 1
 b7e:	30 40       	sbci	r19, 0x00	; 0
 b80:	8f ef       	ldi	r24, 0xFF	; 255
 b82:	2f 3f       	cpi	r18, 0xFF	; 255
 b84:	38 07       	cpc	r19, r24
 b86:	a9 f7       	brne	.-22     	; 0xb72
	}	
	// release CS
	ENC28J60_CONTROL_PORT |= (1<<ENC28J60_CONTROL_CS);
 b88:	c0 9a       	sbi	0x18, 0	; 24
}
 b8a:	08 95       	ret

00000b8c <enc28j60WriteBuffer>:

void enc28j60WriteBuffer(u16 len, u08* data)
{
 b8c:	9c 01       	movw	r18, r24
 b8e:	fb 01       	movw	r30, r22
	// assert CS
	ENC28J60_CONTROL_PORT &= ~(1<<ENC28J60_CONTROL_CS);
 b90:	c0 98       	cbi	0x18, 0	; 24
	
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
 b92:	8a e7       	ldi	r24, 0x7A	; 122
 b94:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));
 b96:	77 9b       	sbis	0x0e, 7	; 14
 b98:	fe cf       	rjmp	.-4      	; 0xb96
	while(len--)
 b9a:	21 50       	subi	r18, 0x01	; 1
 b9c:	30 40       	sbci	r19, 0x00	; 0
 b9e:	8f ef       	ldi	r24, 0xFF	; 255
 ba0:	2f 3f       	cpi	r18, 0xFF	; 255
 ba2:	38 07       	cpc	r19, r24
 ba4:	51 f0       	breq	.+20     	; 0xbba
	{
		// write data
		SPDR = *data++;
 ba6:	81 91       	ld	r24, Z+
 ba8:	8f b9       	out	0x0f, r24	; 15
		while(!(SPSR & (1<<SPIF)));
 baa:	77 9b       	sbis	0x0e, 7	; 14
 bac:	fe cf       	rjmp	.-4      	; 0xbaa
 bae:	21 50       	subi	r18, 0x01	; 1
 bb0:	30 40       	sbci	r19, 0x00	; 0
 bb2:	8f ef       	ldi	r24, 0xFF	; 255
 bb4:	2f 3f       	cpi	r18, 0xFF	; 255
 bb6:	38 07       	cpc	r19, r24
 bb8:	b1 f7       	brne	.-20     	; 0xba6
	}	
	// release CS
	ENC28J60_CONTROL_PORT |= (1<<ENC28J60_CONTROL_CS);
 bba:	c0 9a       	sbi	0x18, 0	; 24
}
 bbc:	08 95       	ret

00000bbe <enc28j60SetBank>:

void enc28j60SetBank(u08 address)
{
 bbe:	1f 93       	push	r17
 bc0:	cf 93       	push	r28
 bc2:	df 93       	push	r29
 bc4:	18 2f       	mov	r17, r24
	// set the bank (if needed)
	if((address & BANK_MASK) != Enc28j60Bank)
 bc6:	c8 2f       	mov	r28, r24
 bc8:	dd 27       	eor	r29, r29
 bca:	c0 76       	andi	r28, 0x60	; 96
 bcc:	d0 70       	andi	r29, 0x00	; 0
 bce:	80 91 80 02 	lds	r24, 0x0280
 bd2:	99 27       	eor	r25, r25
 bd4:	c8 17       	cp	r28, r24
 bd6:	d9 07       	cpc	r29, r25
 bd8:	91 f0       	breq	.+36     	; 0xbfe
	{
		// set the bank
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
 bda:	43 e0       	ldi	r20, 0x03	; 3
 bdc:	6f e1       	ldi	r22, 0x1F	; 31
 bde:	80 ea       	ldi	r24, 0xA0	; 160
 be0:	0e 94 9f 05 	call	0xb3e
		enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
 be4:	85 e0       	ldi	r24, 0x05	; 5
 be6:	d5 95       	asr	r29
 be8:	c7 95       	ror	r28
 bea:	8a 95       	dec	r24
 bec:	e1 f7       	brne	.-8      	; 0xbe6
 bee:	4c 2f       	mov	r20, r28
 bf0:	6f e1       	ldi	r22, 0x1F	; 31
 bf2:	80 e8       	ldi	r24, 0x80	; 128
 bf4:	0e 94 9f 05 	call	0xb3e
		Enc28j60Bank = (address & BANK_MASK);
 bf8:	10 76       	andi	r17, 0x60	; 96
 bfa:	10 93 80 02 	sts	0x0280, r17
	}
}
 bfe:	df 91       	pop	r29
 c00:	cf 91       	pop	r28
 c02:	1f 91       	pop	r17
 c04:	08 95       	ret

00000c06 <enc28j60Read>:

u08 enc28j60Read(u08 address)
{
 c06:	1f 93       	push	r17
 c08:	18 2f       	mov	r17, r24
	// set the bank
	enc28j60SetBank(address);
 c0a:	0e 94 df 05 	call	0xbbe
	// do the read
	return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
 c0e:	61 2f       	mov	r22, r17
 c10:	80 e0       	ldi	r24, 0x00	; 0
 c12:	0e 94 8b 05 	call	0xb16
 c16:	99 27       	eor	r25, r25
}
 c18:	1f 91       	pop	r17
 c1a:	08 95       	ret

00000c1c <enc28j60Write>:

void enc28j60Write(u08 address, u08 data)
{
 c1c:	0f 93       	push	r16
 c1e:	1f 93       	push	r17
 c20:	08 2f       	mov	r16, r24
 c22:	16 2f       	mov	r17, r22
	// set the bank
	enc28j60SetBank(address);
 c24:	0e 94 df 05 	call	0xbbe
	// do the write
	enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
 c28:	41 2f       	mov	r20, r17
 c2a:	60 2f       	mov	r22, r16
 c2c:	80 e4       	ldi	r24, 0x40	; 64
 c2e:	0e 94 9f 05 	call	0xb3e
}
 c32:	1f 91       	pop	r17
 c34:	0f 91       	pop	r16
 c36:	08 95       	ret

00000c38 <enc28j60PhyRead>:

u16 enc28j60PhyRead(u08 address)
{
 c38:	0f 93       	push	r16
 c3a:	1f 93       	push	r17
	u16 data;

	// Set the right address and start the register read operation
	enc28j60Write(MIREGADR, address);
 c3c:	68 2f       	mov	r22, r24
 c3e:	84 ed       	ldi	r24, 0xD4	; 212
 c40:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MICMD, MICMD_MIIRD);
 c44:	61 e0       	ldi	r22, 0x01	; 1
 c46:	82 ed       	ldi	r24, 0xD2	; 210
 c48:	0e 94 0e 06 	call	0xc1c

	// wait until the PHY read completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY);
 c4c:	8a ee       	ldi	r24, 0xEA	; 234
 c4e:	0e 94 03 06 	call	0xc06
 c52:	80 fd       	sbrc	r24, 0
 c54:	fb cf       	rjmp	.-10     	; 0xc4c

	// quit reading
	enc28j60Write(MICMD, 0x00);
 c56:	60 e0       	ldi	r22, 0x00	; 0
 c58:	82 ed       	ldi	r24, 0xD2	; 210
 c5a:	0e 94 0e 06 	call	0xc1c
	
	// get data value
	data  = enc28j60Read(MIRDL);
 c5e:	88 ed       	ldi	r24, 0xD8	; 216
 c60:	0e 94 03 06 	call	0xc06
 c64:	08 2f       	mov	r16, r24
 c66:	11 27       	eor	r17, r17
	data |= enc28j60Read(MIRDH);
 c68:	89 ed       	ldi	r24, 0xD9	; 217
 c6a:	0e 94 03 06 	call	0xc06
 c6e:	99 27       	eor	r25, r25
 c70:	08 2b       	or	r16, r24
 c72:	19 2b       	or	r17, r25
	// return the data
	return data;
}
 c74:	c8 01       	movw	r24, r16
 c76:	1f 91       	pop	r17
 c78:	0f 91       	pop	r16
 c7a:	08 95       	ret

00000c7c <enc28j60PhyWrite>:

void enc28j60PhyWrite(u08 address, u16 data)
{
 c7c:	0f 93       	push	r16
 c7e:	1f 93       	push	r17
 c80:	8b 01       	movw	r16, r22
	// set the PHY register address
	enc28j60Write(MIREGADR, address);
 c82:	68 2f       	mov	r22, r24
 c84:	84 ed       	ldi	r24, 0xD4	; 212
 c86:	0e 94 0e 06 	call	0xc1c
	
	// write the PHY data
	enc28j60Write(MIWRL, data);	
 c8a:	60 2f       	mov	r22, r16
 c8c:	86 ed       	ldi	r24, 0xD6	; 214
 c8e:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MIWRH, data>>8);
 c92:	81 2f       	mov	r24, r17
 c94:	99 27       	eor	r25, r25
 c96:	68 2f       	mov	r22, r24
 c98:	87 ed       	ldi	r24, 0xD7	; 215
 c9a:	0e 94 0e 06 	call	0xc1c

	// wait until the PHY write completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY);
 c9e:	8a ee       	ldi	r24, 0xEA	; 234
 ca0:	0e 94 03 06 	call	0xc06
 ca4:	80 fd       	sbrc	r24, 0
 ca6:	fb cf       	rjmp	.-10     	; 0xc9e
}
 ca8:	1f 91       	pop	r17
 caa:	0f 91       	pop	r16
 cac:	08 95       	ret

00000cae <enc28j60Init>:

void enc28j60Init(void)
{
	// initialize I/O
	sbi(ENC28J60_CONTROL_DDR, ENC28J60_CONTROL_CS);
 cae:	b8 9a       	sbi	0x17, 0	; 23
	sbi(ENC28J60_CONTROL_PORT, ENC28J60_CONTROL_CS);
 cb0:	c0 9a       	sbi	0x18, 0	; 24

	// setup SPI I/O pins
	sbi(PORTB, 1);	// set SCK hi
 cb2:	c1 9a       	sbi	0x18, 1	; 24
	sbi(DDRB, 1);	// set SCK as output
 cb4:	b9 9a       	sbi	0x17, 1	; 23
	cbi(DDRB, 3);	// set MISO as input
 cb6:	bb 98       	cbi	0x17, 3	; 23
	sbi(DDRB, 2);	// set MOSI as output
 cb8:	ba 9a       	sbi	0x17, 2	; 23
	sbi(DDRB, 0);	// SS must be output for Master mode to work
 cba:	b8 9a       	sbi	0x17, 0	; 23
	// initialize SPI interface
	// master mode
	sbi(SPCR, MSTR);
 cbc:	6c 9a       	sbi	0x0d, 4	; 13
	// select clock phase positive-going in middle of data
	cbi(SPCR, CPOL);
 cbe:	6b 98       	cbi	0x0d, 3	; 13
	// Data order MSB first
	cbi(SPCR,DORD);
 cc0:	6d 98       	cbi	0x0d, 5	; 13
	// switch to f/4 2X = f/2 bitrate
	cbi(SPCR, SPR0);
 cc2:	68 98       	cbi	0x0d, 0	; 13
	cbi(SPCR, SPR1);
 cc4:	69 98       	cbi	0x0d, 1	; 13
	sbi(SPSR, SPI2X);
 cc6:	70 9a       	sbi	0x0e, 0	; 14
	// enable SPI
	sbi(SPCR, SPE);
 cc8:	6e 9a       	sbi	0x0d, 6	; 13

	// perform system reset
	enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
 cca:	4f ef       	ldi	r20, 0xFF	; 255
 ccc:	60 e0       	ldi	r22, 0x00	; 0
 cce:	84 2f       	mov	r24, r20
 cd0:	0e 94 9f 05 	call	0xb3e
	// check CLKRDY bit to see if reset is complete
	delay_us(50);
 cd4:	82 e3       	ldi	r24, 0x32	; 50
 cd6:	90 e0       	ldi	r25, 0x00	; 0
 cd8:	0e 94 9f 04 	call	0x93e
	while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
 cdc:	8d e1       	ldi	r24, 0x1D	; 29
 cde:	0e 94 03 06 	call	0xc06
 ce2:	80 ff       	sbrs	r24, 0
 ce4:	fb cf       	rjmp	.-10     	; 0xcdc

	// do bank 0 stuff
	// initialize receive buffer
	// 16-bit transfers, must write low byte first
	// set receive buffer start address
	NextPacketPtr = RXSTART_INIT;
 ce6:	80 e0       	ldi	r24, 0x00	; 0
 ce8:	96 e0       	ldi	r25, 0x06	; 6
 cea:	90 93 7f 02 	sts	0x027F, r25
 cee:	80 93 7e 02 	sts	0x027E, r24
	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
 cf2:	60 e0       	ldi	r22, 0x00	; 0
 cf4:	88 e0       	ldi	r24, 0x08	; 8
 cf6:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
 cfa:	66 e0       	ldi	r22, 0x06	; 6
 cfc:	89 e0       	ldi	r24, 0x09	; 9
 cfe:	0e 94 0e 06 	call	0xc1c
	// set receive pointer address
	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
 d02:	60 e0       	ldi	r22, 0x00	; 0
 d04:	8c e0       	ldi	r24, 0x0C	; 12
 d06:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
 d0a:	66 e0       	ldi	r22, 0x06	; 6
 d0c:	8d e0       	ldi	r24, 0x0D	; 13
 d0e:	0e 94 0e 06 	call	0xc1c
	// set receive buffer end
	// ERXND defaults to 0x1FFF (end of ram)
	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
 d12:	6f ef       	ldi	r22, 0xFF	; 255
 d14:	8a e0       	ldi	r24, 0x0A	; 10
 d16:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
 d1a:	6f e1       	ldi	r22, 0x1F	; 31
 d1c:	8b e0       	ldi	r24, 0x0B	; 11
 d1e:	0e 94 0e 06 	call	0xc1c
	// set transmit buffer start
	// ETXST defaults to 0x0000 (beginnging of ram)
	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
 d22:	60 e0       	ldi	r22, 0x00	; 0
 d24:	84 e0       	ldi	r24, 0x04	; 4
 d26:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
 d2a:	60 e0       	ldi	r22, 0x00	; 0
 d2c:	85 e0       	ldi	r24, 0x05	; 5
 d2e:	0e 94 0e 06 	call	0xc1c

	// do bank 2 stuff
	// enable MAC receive
	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
 d32:	6d e0       	ldi	r22, 0x0D	; 13
 d34:	80 ec       	ldi	r24, 0xC0	; 192
 d36:	0e 94 0e 06 	call	0xc1c
	// bring MAC out of reset
	enc28j60Write(MACON2, 0x00);
 d3a:	60 e0       	ldi	r22, 0x00	; 0
 d3c:	81 ec       	ldi	r24, 0xC1	; 193
 d3e:	0e 94 0e 06 	call	0xc1c
	// enable automatic padding and CRC operations
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
 d42:	42 e3       	ldi	r20, 0x32	; 50
 d44:	62 ec       	ldi	r22, 0xC2	; 194
 d46:	80 e8       	ldi	r24, 0x80	; 128
 d48:	0e 94 9f 05 	call	0xb3e
//	enc28j60Write(MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
	// set inter-frame gap (non-back-to-back)
	enc28j60Write(MAIPGL, 0x12);
 d4c:	62 e1       	ldi	r22, 0x12	; 18
 d4e:	86 ec       	ldi	r24, 0xC6	; 198
 d50:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAIPGH, 0x0C);
 d54:	6c e0       	ldi	r22, 0x0C	; 12
 d56:	87 ec       	ldi	r24, 0xC7	; 199
 d58:	0e 94 0e 06 	call	0xc1c
	// set inter-frame gap (back-to-back)
	enc28j60Write(MABBIPG, 0x12);
 d5c:	62 e1       	ldi	r22, 0x12	; 18
 d5e:	84 ec       	ldi	r24, 0xC4	; 196
 d60:	0e 94 0e 06 	call	0xc1c
	// Set the maximum packet size which the controller will accept
	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
 d64:	6e ee       	ldi	r22, 0xEE	; 238
 d66:	8a ec       	ldi	r24, 0xCA	; 202
 d68:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
 d6c:	65 e0       	ldi	r22, 0x05	; 5
 d6e:	8b ec       	ldi	r24, 0xCB	; 203
 d70:	0e 94 0e 06 	call	0xc1c

	// do bank 3 stuff
	// write MAC address
	// NOTE: MAC address in ENC28J60 is byte-backward
	enc28j60Write(MAADR5, ENC28J60_MAC0);
 d74:	60 e3       	ldi	r22, 0x30	; 48
 d76:	84 ee       	ldi	r24, 0xE4	; 228
 d78:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR4, ENC28J60_MAC1);
 d7c:	66 e4       	ldi	r22, 0x46	; 70
 d7e:	85 ee       	ldi	r24, 0xE5	; 229
 d80:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR3, ENC28J60_MAC2);
 d84:	66 e4       	ldi	r22, 0x46	; 70
 d86:	82 ee       	ldi	r24, 0xE2	; 226
 d88:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR2, ENC28J60_MAC3);
 d8c:	69 e4       	ldi	r22, 0x49	; 73
 d8e:	83 ee       	ldi	r24, 0xE3	; 227
 d90:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR1, ENC28J60_MAC4);
 d94:	63 e4       	ldi	r22, 0x43	; 67
 d96:	80 ee       	ldi	r24, 0xE0	; 224
 d98:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(MAADR0, ENC28J60_MAC5);
 d9c:	65 e4       	ldi	r22, 0x45	; 69
 d9e:	81 ee       	ldi	r24, 0xE1	; 225
 da0:	0e 94 0e 06 	call	0xc1c

	// no loopback of transmitted frames
	enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
 da4:	60 e0       	ldi	r22, 0x00	; 0
 da6:	71 e0       	ldi	r23, 0x01	; 1
 da8:	80 e1       	ldi	r24, 0x10	; 16
 daa:	0e 94 3e 06 	call	0xc7c

	// switch to bank 0
	enc28j60SetBank(ECON1);
 dae:	8f e1       	ldi	r24, 0x1F	; 31
 db0:	0e 94 df 05 	call	0xbbe
	// enable interrutps
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
 db4:	40 ec       	ldi	r20, 0xC0	; 192
 db6:	6b e1       	ldi	r22, 0x1B	; 27
 db8:	80 e8       	ldi	r24, 0x80	; 128
 dba:	0e 94 9f 05 	call	0xb3e
	// enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
 dbe:	44 e0       	ldi	r20, 0x04	; 4
 dc0:	6f e1       	ldi	r22, 0x1F	; 31
 dc2:	80 e8       	ldi	r24, 0x80	; 128
 dc4:	0e 94 9f 05 	call	0xb3e
/*
	enc28j60PhyWrite(PHLCON, 0x0AA2);

	// setup duplex ----------------------

	// Disable receive logic and abort any packets currently being transmitted
	enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS|ECON1_RXEN);
	
	{
		u16 temp;
		// Set the PHY to the proper duplex mode
		temp = enc28j60PhyRead(PHCON1);
		temp &= ~PHCON1_PDPXMD;
		enc28j60PhyWrite(PHCON1, temp);
		// Set the MAC to the proper duplex mode
		temp = enc28j60Read(MACON3);
		temp &= ~MACON3_FULDPX;
		enc28j60Write(MACON3, temp);
	}

	// Set the back-to-back inter-packet gap time to IEEE specified 
	// requirements.  The meaning of the MABBIPG value changes with the duplex
	// state, so it must be updated in this function.
	// In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex
	//enc28j60Write(MABBIPG, DuplexState ? 0x15 : 0x12);	
	
	// Reenable receive logic
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);

	// setup duplex ----------------------
*/
}
 dc8:	08 95       	ret

00000dca <enc28j60PacketSend>:

void enc28j60PacketSend(unsigned int len, unsigned char* packet)
{
 dca:	ef 92       	push	r14
 dcc:	ff 92       	push	r15
 dce:	0f 93       	push	r16
 dd0:	1f 93       	push	r17
 dd2:	8c 01       	movw	r16, r24
 dd4:	7b 01       	movw	r14, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT);
 dd6:	60 e0       	ldi	r22, 0x00	; 0
 dd8:	82 e0       	ldi	r24, 0x02	; 2
 dda:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
 dde:	60 e0       	ldi	r22, 0x00	; 0
 de0:	83 e0       	ldi	r24, 0x03	; 3
 de2:	0e 94 0e 06 	call	0xc1c
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len));
 de6:	60 2f       	mov	r22, r16
 de8:	86 e0       	ldi	r24, 0x06	; 6
 dea:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
 dee:	81 2f       	mov	r24, r17
 df0:	99 27       	eor	r25, r25
 df2:	68 2f       	mov	r22, r24
 df4:	87 e0       	ldi	r24, 0x07	; 7
 df6:	0e 94 0e 06 	call	0xc1c

	// write per-packet control byte
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
 dfa:	40 e0       	ldi	r20, 0x00	; 0
 dfc:	64 2f       	mov	r22, r20
 dfe:	8a e7       	ldi	r24, 0x7A	; 122
 e00:	0e 94 9f 05 	call	0xb3e

	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
 e04:	b7 01       	movw	r22, r14
 e06:	c8 01       	movw	r24, r16
 e08:	0e 94 c6 05 	call	0xb8c
	
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
 e0c:	48 e0       	ldi	r20, 0x08	; 8
 e0e:	6f e1       	ldi	r22, 0x1F	; 31
 e10:	80 e8       	ldi	r24, 0x80	; 128
 e12:	0e 94 9f 05 	call	0xb3e
}
 e16:	1f 91       	pop	r17
 e18:	0f 91       	pop	r16
 e1a:	ff 90       	pop	r15
 e1c:	ef 90       	pop	r14
 e1e:	08 95       	ret

00000e20 <enc28j60PacketReceive>:

unsigned int enc28j60PacketReceive(unsigned int maxlen, unsigned char* packet)
{
 e20:	ef 92       	push	r14
 e22:	ff 92       	push	r15
 e24:	0f 93       	push	r16
 e26:	1f 93       	push	r17
 e28:	cf 93       	push	r28
 e2a:	df 93       	push	r29
 e2c:	8c 01       	movw	r16, r24
 e2e:	7b 01       	movw	r14, r22
	u16 rxstat;
	u16 len;

	// check if a packet has been received and buffered
	if( !(enc28j60Read(EIR) & EIR_PKTIF) )
 e30:	8c e1       	ldi	r24, 0x1C	; 28
 e32:	0e 94 03 06 	call	0xc06
 e36:	99 27       	eor	r25, r25
 e38:	9c 01       	movw	r18, r24
 e3a:	20 74       	andi	r18, 0x40	; 64
 e3c:	30 70       	andi	r19, 0x00	; 0
 e3e:	86 fd       	sbrc	r24, 6
 e40:	02 c0       	rjmp	.+4      	; 0xe46
		return 0;
 e42:	c9 01       	movw	r24, r18
 e44:	5d c0       	rjmp	.+186    	; 0xf00
	
	// Make absolutely certain that any previous packet was discarded	
	//if( WasDiscarded == FALSE)
	//	MACDiscardRx();

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
 e46:	60 91 7e 02 	lds	r22, 0x027E
 e4a:	80 e0       	ldi	r24, 0x00	; 0
 e4c:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
 e50:	80 91 7e 02 	lds	r24, 0x027E
 e54:	90 91 7f 02 	lds	r25, 0x027F
 e58:	89 2f       	mov	r24, r25
 e5a:	99 27       	eor	r25, r25
 e5c:	68 2f       	mov	r22, r24
 e5e:	81 e0       	ldi	r24, 0x01	; 1
 e60:	0e 94 0e 06 	call	0xc1c
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 e64:	60 e0       	ldi	r22, 0x00	; 0
 e66:	8a e3       	ldi	r24, 0x3A	; 58
 e68:	0e 94 8b 05 	call	0xb16
 e6c:	99 27       	eor	r25, r25
 e6e:	90 93 7f 02 	sts	0x027F, r25
 e72:	80 93 7e 02 	sts	0x027E, r24
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
 e76:	60 e0       	ldi	r22, 0x00	; 0
 e78:	8a e3       	ldi	r24, 0x3A	; 58
 e7a:	0e 94 8b 05 	call	0xb16
 e7e:	99 27       	eor	r25, r25
 e80:	38 2f       	mov	r19, r24
 e82:	22 27       	eor	r18, r18
 e84:	80 91 7e 02 	lds	r24, 0x027E
 e88:	90 91 7f 02 	lds	r25, 0x027F
 e8c:	82 2b       	or	r24, r18
 e8e:	93 2b       	or	r25, r19
 e90:	90 93 7f 02 	sts	0x027F, r25
 e94:	80 93 7e 02 	sts	0x027E, r24
	// read the packet length
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 e98:	60 e0       	ldi	r22, 0x00	; 0
 e9a:	8a e3       	ldi	r24, 0x3A	; 58
 e9c:	0e 94 8b 05 	call	0xb16
 ea0:	c8 2f       	mov	r28, r24
 ea2:	dd 27       	eor	r29, r29
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
 ea4:	60 e0       	ldi	r22, 0x00	; 0
 ea6:	8a e3       	ldi	r24, 0x3A	; 58
 ea8:	0e 94 8b 05 	call	0xb16
 eac:	99 27       	eor	r25, r25
 eae:	98 2f       	mov	r25, r24
 eb0:	88 27       	eor	r24, r24
 eb2:	c8 2b       	or	r28, r24
 eb4:	d9 2b       	or	r29, r25
	// read the receive status
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 eb6:	60 e0       	ldi	r22, 0x00	; 0
 eb8:	8a e3       	ldi	r24, 0x3A	; 58
 eba:	0e 94 8b 05 	call	0xb16
	rxstat |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
 ebe:	60 e0       	ldi	r22, 0x00	; 0
 ec0:	8a e3       	ldi	r24, 0x3A	; 58
 ec2:	0e 94 8b 05 	call	0xb16

	// limit retrieve length
	// (we reduce the MAC-reported length by 4 to remove the CRC)
	if(len>maxlen)
 ec6:	0c 17       	cp	r16, r28
 ec8:	1d 07       	cpc	r17, r29
 eca:	08 f4       	brcc	.+2      	; 0xece
		len=maxlen;
 ecc:	e8 01       	movw	r28, r16

	// copy the packet from the receive buffer
	enc28j60ReadBuffer(len, packet);
 ece:	b7 01       	movw	r22, r14
 ed0:	ce 01       	movw	r24, r28
 ed2:	0e 94 ac 05 	call	0xb58

	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
 ed6:	60 91 7e 02 	lds	r22, 0x027E
 eda:	8c e0       	ldi	r24, 0x0C	; 12
 edc:	0e 94 0e 06 	call	0xc1c
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
 ee0:	80 91 7e 02 	lds	r24, 0x027E
 ee4:	90 91 7f 02 	lds	r25, 0x027F
 ee8:	89 2f       	mov	r24, r25
 eea:	99 27       	eor	r25, r25
 eec:	68 2f       	mov	r22, r24
 eee:	8d e0       	ldi	r24, 0x0D	; 13
 ef0:	0e 94 0e 06 	call	0xc1c

	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
 ef4:	40 e4       	ldi	r20, 0x40	; 64
 ef6:	6e e1       	ldi	r22, 0x1E	; 30
 ef8:	80 e8       	ldi	r24, 0x80	; 128
 efa:	0e 94 9f 05 	call	0xb3e

	return len;
 efe:	ce 01       	movw	r24, r28
}
 f00:	df 91       	pop	r29
 f02:	cf 91       	pop	r28
 f04:	1f 91       	pop	r17
 f06:	0f 91       	pop	r16
 f08:	ff 90       	pop	r15
 f0a:	ef 90       	pop	r14
 f0c:	08 95       	ret

00000f0e <enc28j60ReceiveOverflowRecover>:

void enc28j60ReceiveOverflowRecover(void)
{
 f0e:	08 95       	ret

00000f10 <enc28j60RegDump>:
	// receive buffer overflow handling procedure

	// recovery completed
}

void enc28j60RegDump(void)
{
 f10:	08 95       	ret

00000f12 <nicRegDump>:
 f12:	0e 94 88 07 	call	0xf10
 f16:	08 95       	ret

00000f18 <eeprom_read_byte>:
 f18:	e1 99       	sbic	0x1c, 1	; 28
 f1a:	fe cf       	rjmp	.-4      	; 0xf18
 f1c:	9f bb       	out	0x1f, r25	; 31
 f1e:	8e bb       	out	0x1e, r24	; 30
 f20:	e0 9a       	sbi	0x1c, 0	; 28
 f22:	99 27       	eor	r25, r25
 f24:	8d b3       	in	r24, 0x1d	; 29
 f26:	08 95       	ret

00000f28 <eeprom_write_byte>:
 f28:	e1 99       	sbic	0x1c, 1	; 28
 f2a:	fe cf       	rjmp	.-4      	; 0xf28
 f2c:	9f bb       	out	0x1f, r25	; 31
 f2e:	8e bb       	out	0x1e, r24	; 30
 f30:	6d bb       	out	0x1d, r22	; 29
 f32:	0f b6       	in	r0, 0x3f	; 63
 f34:	f8 94       	cli
 f36:	e2 9a       	sbi	0x1c, 2	; 28
 f38:	e1 9a       	sbi	0x1c, 1	; 28
 f3a:	0f be       	out	0x3f, r0	; 63
 f3c:	08 95       	ret

00000f3e <__udivmodhi4>:
 f3e:	aa 1b       	sub	r26, r26
 f40:	bb 1b       	sub	r27, r27
 f42:	51 e1       	ldi	r21, 0x11	; 17
 f44:	07 c0       	rjmp	.+14     	; 0xf54

00000f46 <__udivmodhi4_loop>:
 f46:	aa 1f       	adc	r26, r26
 f48:	bb 1f       	adc	r27, r27
 f4a:	a6 17       	cp	r26, r22
 f4c:	b7 07       	cpc	r27, r23
 f4e:	10 f0       	brcs	.+4      	; 0xf54
 f50:	a6 1b       	sub	r26, r22
 f52:	b7 0b       	sbc	r27, r23

00000f54 <__udivmodhi4_ep>:
 f54:	88 1f       	adc	r24, r24
 f56:	99 1f       	adc	r25, r25
 f58:	5a 95       	dec	r21
 f5a:	a9 f7       	brne	.-22     	; 0xf46
 f5c:	80 95       	com	r24
 f5e:	90 95       	com	r25
 f60:	bc 01       	movw	r22, r24
 f62:	cd 01       	movw	r24, r26
 f64:	08 95       	ret
